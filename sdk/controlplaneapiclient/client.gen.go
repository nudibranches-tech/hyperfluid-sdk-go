// Package controlplaneapiclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package controlplaneapiclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Api_keyScopes       = "api_key.Scopes"
	Shared_secretScopes = "shared_secret.Scopes"
)

// Defines values for ArchiveFileType.
const (
	Applicationzip ArchiveFileType = "application/zip"
)

// Defines values for ArchiveOperationStatus.
const (
	ArchiveOperationStatusCompleted  ArchiveOperationStatus = "completed"
	ArchiveOperationStatusFailed     ArchiveOperationStatus = "failed"
	ArchiveOperationStatusPending    ArchiveOperationStatus = "pending"
	ArchiveOperationStatusProcessing ArchiveOperationStatus = "processing"
)

// Defines values for ArchiveOperationType.
const (
	Export ArchiveOperationType = "export"
	Import ArchiveOperationType = "import"
)

// Defines values for ConsoleConfigFeatureFlag.
const (
	ShowDemoBanner ConsoleConfigFeatureFlag = "show_demo_banner"
	VaubanPreview  ConsoleConfigFeatureFlag = "vauban_preview"
)

// Defines values for CreatePipelineRequestV20Type.
const (
	CreatePipelineRequestV20TypeFileSorter CreatePipelineRequestV20Type = "file_sorter"
)

// Defines values for CreatePipelineRequestV21Type.
const (
	CreatePipelineRequestV21TypeTrino CreatePipelineRequestV21Type = "trino"
)

// Defines values for CreatePipelineRequestV22Type.
const (
	FileRouter CreatePipelineRequestV22Type = "file_router"
)

// Defines values for CreatePipelineRequestV23Type.
const (
	CreatePipelineRequestV23TypeCopy CreatePipelineRequestV23Type = "copy"
)

// Defines values for CreatePipelineRequestV24Type.
const (
	S3Copy CreatePipelineRequestV24Type = "s3_copy"
)

// Defines values for DataDockKind0Type.
const (
	DataDockKind0TypeTrino DataDockKind0Type = "Trino"
)

// Defines values for DataDockKind1Type.
const (
	DataDockKind1TypeTrinoInternal DataDockKind1Type = "TrinoInternal"
)

// Defines values for DataDockKind2Type.
const (
	DataDockKind2TypeMinioInternal DataDockKind2Type = "MinioInternal"
)

// Defines values for DataDockKind3Type.
const (
	DataDockKind3TypePostgresInternal DataDockKind3Type = "PostgresInternal"
)

// Defines values for DataDockKind4Type.
const (
	DataDockKind4TypeCephRgwInternal DataDockKind4Type = "CephRgwInternal"
)

// Defines values for DataDockKindRequest0Type.
const (
	DataDockKindRequest0TypeTrino DataDockKindRequest0Type = "Trino"
)

// Defines values for DataDockKindRequest1Type.
const (
	DataDockKindRequest1TypeTrinoInternal DataDockKindRequest1Type = "TrinoInternal"
)

// Defines values for DataDockKindRequest2Type.
const (
	DataDockKindRequest2TypeMinioInternal DataDockKindRequest2Type = "MinioInternal"
)

// Defines values for DataDockKindRequest3Type.
const (
	DataDockKindRequest3TypePostgresInternal DataDockKindRequest3Type = "PostgresInternal"
)

// Defines values for DataDockKindRequest4Type.
const (
	DataDockKindRequest4TypeCephRgwInternal DataDockKindRequest4Type = "CephRgwInternal"
)

// Defines values for DataDockKindResponse0Type.
const (
	DataDockKindResponse0TypeTrino DataDockKindResponse0Type = "Trino"
)

// Defines values for DataDockKindResponse1Type.
const (
	TrinoInternal DataDockKindResponse1Type = "TrinoInternal"
)

// Defines values for DataDockKindResponse2Type.
const (
	MinioInternal DataDockKindResponse2Type = "MinioInternal"
)

// Defines values for DataDockKindResponse3Type.
const (
	PostgresInternal DataDockKindResponse3Type = "PostgresInternal"
)

// Defines values for DataDockKindResponse4Type.
const (
	CephRgwInternal DataDockKindResponse4Type = "CephRgwInternal"
)

// Defines values for DataDockStatus.
const (
	DataDockStatusOffline  DataDockStatus = "Offline"
	DataDockStatusOnline   DataDockStatus = "Online"
	DataDockStatusPending  DataDockStatus = "Pending"
	DataDockStatusSleeping DataDockStatus = "Sleeping"
)

// Defines values for HfDataType.
const (
	Boolean     HfDataType = "Boolean"
	Date        HfDataType = "Date"
	Double      HfDataType = "Double"
	Float       HfDataType = "Float"
	Int         HfDataType = "Int"
	String      HfDataType = "String"
	StringArray HfDataType = "StringArray"
	Timestamp   HfDataType = "Timestamp"
)

// Defines values for ModelRuntime.
const (
	Tgi  ModelRuntime = "tgi"
	Vllm ModelRuntime = "vllm"
)

// Defines values for ModelServingPhase.
const (
	ModelServingPhaseFailed       ModelServingPhase = "Failed"
	ModelServingPhasePending      ModelServingPhase = "Pending"
	ModelServingPhaseProvisioning ModelServingPhase = "Provisioning"
	ModelServingPhaseReady        ModelServingPhase = "Ready"
	ModelServingPhaseTerminating  ModelServingPhase = "Terminating"
)

// Defines values for ModelType.
const (
	Embedding  ModelType = "embedding"
	Generation ModelType = "generation"
)

// Defines values for PipelineOutputParameters0Type.
const (
	Trino PipelineOutputParameters0Type = "trino"
)

// Defines values for PipelineOutputParameters1Type.
const (
	S3 PipelineOutputParameters1Type = "s3"
)

// Defines values for PipelineOutputParameters2Type.
const (
	Filesorter PipelineOutputParameters2Type = "filesorter"
)

// Defines values for PipelineOutputParameters3Type.
const (
	PipelineOutputParameters3TypeCopy PipelineOutputParameters3Type = "copy"
)

// Defines values for PipelineRunStatus.
const (
	PipelineRunStatusCompleted PipelineRunStatus = "completed"
	PipelineRunStatusFailed    PipelineRunStatus = "failed"
	PipelineRunStatusPending   PipelineRunStatus = "pending"
	PipelineRunStatusRunning   PipelineRunStatus = "running"
)

// Defines values for PipelineType.
const (
	PipelineTypeCopy             PipelineType = "Copy"
	PipelineTypeFileRouter       PipelineType = "FileRouter"
	PipelineTypeFileSorter       PipelineType = "FileSorter"
	PipelineTypeHephaistosPdfeed PipelineType = "HephaistosPdfeed"
	PipelineTypeLabelizer        PipelineType = "Labelizer"
	PipelineTypeMarkitdown       PipelineType = "Markitdown"
)

// Defines values for PrepareArchiveImportResponse0UploadType.
const (
	Simple PrepareArchiveImportResponse0UploadType = "simple"
)

// Defines values for PrepareArchiveImportResponse1UploadType.
const (
	Multipart PrepareArchiveImportResponse1UploadType = "multipart"
)

// Defines values for RefStatus.
const (
	Done    RefStatus = "done"
	Failed  RefStatus = "failed"
	Pending RefStatus = "pending"
	Skipped RefStatus = "skipped"
)

// Defines values for SensitivityLevel.
const (
	Confidential SensitivityLevel = "confidential"
	Internal     SensitivityLevel = "internal"
	Public       SensitivityLevel = "public"
	Restricted   SensitivityLevel = "restricted"
)

// AbortMultipartUploadRequest defines model for AbortMultipartUploadRequest.
type AbortMultipartUploadRequest struct {
	// Bucket The bucket name
	Bucket string `json:"bucket"`

	// DestinationDataContainerId The data container where the file was being uploaded
	DestinationDataContainerId openapi_types.UUID `json:"destination_data_container_id"`

	// Key The object key in the bucket
	Key string `json:"key"`

	// UploadId The S3 multipart upload ID
	UploadId string `json:"upload_id"`
}

// AddUser defines model for AddUser.
type AddUser struct {
	Email string `json:"email"`
}

// AddUserAttributeRequest Request to add a single attribute to a user.
type AddUserAttributeRequest struct {
	// Attribute Attribute in `namespace::value` format.
	// Example: `"region::occitanie"`
	Attribute string `json:"attribute"`
}

// AiClassificationResultResponse Response for AI classification result.
type AiClassificationResultResponse struct {
	ComplianceTags []string `json:"compliance_tags"`
	Confidence     float32  `json:"confidence"`
	Reasoning      string   `json:"reasoning"`

	// Sensitivity Sensitivity level for data classification
	Sensitivity SensitivityLevel `json:"sensitivity"`
	TableFqdn   string           `json:"table_fqdn"`
}

// AiClassifyRequestBody Request for AI classification.
type AiClassifyRequestBody struct {
	DataDockId openapi_types.UUID `json:"data_dock_id"`

	// ModelName Optional model name (defaults to org's configured model)
	ModelName *string `json:"model_name"`

	// TableFqdns List of fully qualified table names to classify
	TableFqdns []string `json:"table_fqdns"`
}

// AiClassifyResponseBody Response for AI classification operation.
type AiClassifyResponseBody struct {
	ClassifiedCount int                              `json:"classified_count"`
	FailedCount     int                              `json:"failed_count"`
	Results         []AiClassificationResultResponse `json:"results"`
}

// ApiKeyResponse defines model for ApiKeyResponse.
type ApiKeyResponse struct {
	CreatedAt  time.Time          `json:"created_at"`
	ExpiresAt  *time.Time         `json:"expires_at"`
	Id         openapi_types.UUID `json:"id"`
	KeyPrefix  string             `json:"key_prefix"`
	LastUsedAt *time.Time         `json:"last_used_at"`
	Name       string             `json:"name"`
	Scopes     []string           `json:"scopes"`
}

// ArchiveDownloadResponse defines model for ArchiveDownloadResponse.
type ArchiveDownloadResponse struct {
	ExpiresInSeconds int64  `json:"expires_in_seconds"`
	Url              string `json:"url"`
}

// ArchiveExportRequest defines model for ArchiveExportRequest.
type ArchiveExportRequest struct {
	DestinationDataContainerId openapi_types.UUID `json:"destination_data_container_id"`
	DestinationFileName        string             `json:"destination_file_name"`
	DestinationFilePath        *string            `json:"destination_file_path"`
	Prefix                     *string            `json:"prefix"`

	// StripPrefix Whether to strip the prefix from file paths in the archive
	StripPrefix *bool `json:"strip_prefix"`
}

// ArchiveFileType defines model for ArchiveFileType.
type ArchiveFileType string

// ArchiveImportRequest defines model for ArchiveImportRequest.
type ArchiveImportRequest struct {
	DedupingStrategy *DedupingStrategy `json:"deduping_strategy,omitempty"`

	// DestinationDataContainerId The bucket where the zip file is stored
	DestinationDataContainerId openapi_types.UUID `json:"destination_data_container_id"`

	// FilePath The full path to the uploaded file (from prepare_archive_import response)
	FilePath string `json:"file_path"`

	// Prefix Optional prefix where files will be extracted in the target bucket
	Prefix *string `json:"prefix"`
}

// ArchiveOperationStatus defines model for ArchiveOperationStatus.
type ArchiveOperationStatus string

// ArchiveOperationType defines model for ArchiveOperationType.
type ArchiveOperationType string

// BucketArchiveOperation defines model for BucketArchiveOperation.
type BucketArchiveOperation struct {
	CreatedAt time.Time `json:"created_at"`

	// DataContainerId The data container to import to/export from
	DataContainerId  openapi_types.UUID `json:"data_container_id"`
	DedupingStrategy *DedupingStrategy  `json:"deduping_strategy,omitempty"`

	// DestinationDataContainerId The data container where the files will be extracted to when importing
	// or where the files will be extracted from when exporting
	DestinationDataContainerId openapi_types.UUID `json:"destination_data_container_id"`
	ErrorMessage               *string            `json:"error_message"`

	// FileName The name of the archive file
	FileName string `json:"file_name"`

	// FilePath The path of the archive file
	FilePath *string `json:"file_path"`

	// FileSize The size of the archive file
	FileSize       *int64               `json:"file_size"`
	FileType       ArchiveFileType      `json:"file_type"`
	Id             openapi_types.UUID   `json:"id"`
	OperationType  ArchiveOperationType `json:"operation_type"`
	OrganizationId openapi_types.UUID   `json:"organization_id"`

	// Prefix If the operation is an import, the prefix to add to all files when extracting the archive
	// If the operation is an export, the prefix to filter which files to include in the export (only files matching this prefix will be exported)
	Prefix *string                `json:"prefix"`
	Status ArchiveOperationStatus `json:"status"`

	// StripPrefix Whether to strip the prefix from file paths when creating the archive (export only)
	StripPrefix bool      `json:"strip_prefix"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// BucketFile defines model for BucketFile.
type BucketFile struct {
	IsFolder     bool       `json:"is_folder"`
	LastModified *time.Time `json:"last_modified"`
	Name         string     `json:"name"`
	Path         string     `json:"path"`
	Size         *int64     `json:"size"`
}

// BucketStats defines model for BucketStats.
type BucketStats struct {
	LastModified *time.Time `json:"lastModified"`
	TotalFiles   int64      `json:"totalFiles"`
	TotalFolders int64      `json:"totalFolders"`
	TotalSize    int64      `json:"totalSize"`
}

// CategoryRouterConfig Category router configuration (CategoryRouterMetadataAware step)
type CategoryRouterConfig struct {
	// DefaultCategory Default category if no label matches (e.g., "inconnu")
	DefaultCategory *string `json:"default_category"`

	// PrefixRegex Regex to extract prefix from source path (single capture group)
	// Example: "(condominium-\\d+)/"
	PrefixRegex *string `json:"prefix_regex"`
}

// CephRgwInternalConfig defines model for CephRgwInternalConfig.
type CephRgwInternalConfig struct {
	// ReplicationSize Data replication factor (default: 3)
	ReplicationSize *int32            `json:"replication_size,omitempty"`
	Resources       *CephRgwResources `json:"resources,omitempty"`

	// RgwInstances Number of RGW gateway instances for HA (default: 2)
	RgwInstances *int32 `json:"rgw_instances,omitempty"`

	// StorageQuotaGb Storage quota in Gigabytes (tenant-level quota)
	StorageQuotaGb int32 `json:"storage_quota_gb"`
}

// CephRgwInternalConfigResponse defines model for CephRgwInternalConfigResponse.
type CephRgwInternalConfigResponse struct {
	CpuLimit        *string `json:"cpu_limit"`
	CpuRequest      *string `json:"cpu_request"`
	MemoryLimit     *string `json:"memory_limit"`
	MemoryRequest   *string `json:"memory_request"`
	ReplicationSize int32   `json:"replication_size"`
	RgwInstances    int32   `json:"rgw_instances"`
	StorageQuotaGb  int32   `json:"storage_quota_gb"`
}

// CephRgwResources defines model for CephRgwResources.
type CephRgwResources struct {
	// CpuLimit CPU limit (e.g., "2")
	CpuLimit *string `json:"cpu_limit"`

	// CpuRequest CPU request (e.g., "500m")
	CpuRequest *string `json:"cpu_request"`

	// MemoryLimit Memory limit (e.g., "4Gi")
	MemoryLimit *string `json:"memory_limit"`

	// MemoryRequest Memory request (e.g., "1Gi")
	MemoryRequest *string `json:"memory_request"`
}

// CheckNameAvailabilityResponseData defines model for CheckNameAvailabilityResponseData.
type CheckNameAvailabilityResponseData struct {
	Available bool `json:"available"`
}

// CheckOrganizationNameAvailabilityResponseData defines model for CheckOrganizationNameAvailabilityResponseData.
type CheckOrganizationNameAvailabilityResponseData struct {
	Available bool `json:"available"`
}

// ClassificationConfig Classification configuration for AI processing
type ClassificationConfig struct {
	// ApiKey API key for the AI model (e.g., Mistral)
	ApiKey string `json:"api_key"`

	// Labels Document classification labels
	Labels []LabelDefinition `json:"labels"`

	// ModelName Model name (e.g., "mistral-large-latest")
	ModelName string `json:"model_name"`
}

// ClassificationStatsResponse Response for classification statistics.
type ClassificationStatsResponse struct {
	AiClassifiedCount     int64 `json:"ai_classified_count"`
	ClassifiedCount       int64 `json:"classified_count"`
	ConfidentialCount     int64 `json:"confidential_count"`
	FinancialCount        int64 `json:"financial_count"`
	InternalCount         int64 `json:"internal_count"`
	LegalCount            int64 `json:"legal_count"`
	ManualClassifiedCount int64 `json:"manual_classified_count"`
	PciCount              int64 `json:"pci_count"`
	PhiCount              int64 `json:"phi_count"`
	PiiCount              int64 `json:"pii_count"`
	PublicCount           int64 `json:"public_count"`
	RestrictedCount       int64 `json:"restricted_count"`
	TotalTables           int64 `json:"total_tables"`
}

// CloneIcebergTableRequestBody defines model for CloneIcebergTableRequestBody.
type CloneIcebergTableRequestBody struct {
	SourceSchemaName string `json:"source_schema_name"`
	SourceTableName  string `json:"source_table_name"`
	TargetSchemaName string `json:"target_schema_name"`
	TargetTableName  string `json:"target_table_name"`
}

// CompleteMultipartUploadRequest defines model for CompleteMultipartUploadRequest.
type CompleteMultipartUploadRequest struct {
	// Bucket The bucket name
	Bucket string `json:"bucket"`

	// DestinationDataContainerId The data container where the file is being uploaded
	DestinationDataContainerId openapi_types.UUID `json:"destination_data_container_id"`

	// Key The object key in the bucket
	Key string `json:"key"`

	// Parts List of completed parts with their ETags
	Parts []CompletedPartInfo `json:"parts"`

	// UploadId The S3 multipart upload ID
	UploadId string `json:"upload_id"`
}

// CompletedPartInfo Information about a completed part, used when finalizing multipart upload
type CompletedPartInfo struct {
	// ETag ETag returned by S3 after uploading the part
	ETag string `json:"e_tag"`

	// PartNumber Part number (1-indexed as per S3 API)
	PartNumber int32 `json:"part_number"`
}

// ConsoleConfigFeatureFlag defines model for ConsoleConfigFeatureFlag.
type ConsoleConfigFeatureFlag string

// ContextProviderResponse Response for a context provider.
type ContextProviderResponse struct {
	CreatedAt           time.Time          `json:"created_at"`
	Enabled             bool               `json:"enabled"`
	Id                  openapi_types.UUID `json:"id"`
	LastSyncAt          *time.Time         `json:"last_sync_at"`
	LastSyncError       *string            `json:"last_sync_error"`
	LastSyncStatus      *string            `json:"last_sync_status"`
	LastSyncUserCount   *int32             `json:"last_sync_user_count"`
	Name                string             `json:"name"`
	OrganizationId      openapi_types.UUID `json:"organization_id"`
	ProviderType        string             `json:"provider_type"`
	SyncIntervalSeconds int32              `json:"sync_interval_seconds"`
	UpdatedAt           time.Time          `json:"updated_at"`
}

// ContextualRestrictionResponse Response for a contextual restriction.
type ContextualRestrictionResponse struct {
	CreatedAt       time.Time           `json:"created_at"`
	DataDockId      *openapi_types.UUID `json:"data_dock_id"`
	DataSelector    interface{}         `json:"data_selector"`
	Description     *string             `json:"description"`
	Enabled         bool                `json:"enabled"`
	Id              openapi_types.UUID  `json:"id"`
	Name            string              `json:"name"`
	OrganizationId  openapi_types.UUID  `json:"organization_id"`
	Priority        int32               `json:"priority"`
	UpdatedAt       time.Time           `json:"updated_at"`
	UserRequirement interface{}         `json:"user_requirement"`
}

// CopyDestinationConfig Copy pipeline destination configuration (S3 bucket)
type CopyDestinationConfig struct {
	// DataContainerId Data Container ID for the destination bucket (DataDock is resolved automatically)
	DataContainerId openapi_types.UUID `json:"data_container_id"`

	// DestinationPrefix Optional prefix path within the destination bucket
	DestinationPrefix *string `json:"destination_prefix"`
}

// CopyOutputParameters Copy pipeline output configuration - S3 destination for imported files
type CopyOutputParameters struct {
	// DestinationBucketId UUID of the destination bucket Data Container
	DestinationBucketId openapi_types.UUID `json:"destination_bucket_id"`

	// DestinationDd UUID of the destination MinIO Data Dock
	DestinationDd openapi_types.UUID `json:"destination_dd"`

	// DestinationPrefix Optional prefix path within the destination bucket
	DestinationPrefix *string `json:"destination_prefix"`
}

// CopyS3SourceConfig S3 source configuration for S3-to-S3 copy
type CopyS3SourceConfig struct {
	// DataContainerId Data Container ID for the source S3 bucket (DataDock is resolved automatically)
	DataContainerId openapi_types.UUID `json:"data_container_id"`

	// SourcePrefix Optional prefix to filter source files (stripped during copy)
	SourcePrefix *string `json:"source_prefix"`
}

// CopySourceConfig Copy pipeline source configuration (Import API)
type CopySourceConfig struct {
	// ImportApiKey Import API Key for authentication
	ImportApiKey string `json:"import_api_key"`

	// ImportApiUrl Import API URL (source endpoint)
	ImportApiUrl string `json:"import_api_url"`
}

// CountRefRequest defines model for CountRefRequest.
type CountRefRequest struct {
	Key             *string    `json:"key"`
	Locked          *bool      `json:"locked"`
	Status          *RefStatus `json:"status,omitempty"`
	UpdatedAtAfter  *time.Time `json:"updated_at_after"`
	UpdatedAtBefore *time.Time `json:"updated_at_before"`
}

// CreateApiKeyRequest defines model for CreateApiKeyRequest.
type CreateApiKeyRequest struct {
	ExpiresInDays *int32    `json:"expires_in_days"`
	Name          string    `json:"name"`
	Scopes        *[]string `json:"scopes,omitempty"`
}

// CreateApiKeyResponse defines model for CreateApiKeyResponse.
type CreateApiKeyResponse struct {
	CreatedAt time.Time          `json:"created_at"`
	ExpiresAt *time.Time         `json:"expires_at"`
	Id        openapi_types.UUID `json:"id"`
	Key       string             `json:"key"`
	KeyPrefix string             `json:"key_prefix"`
	Name      string             `json:"name"`
	Scopes    []string           `json:"scopes"`
}

// CreateBucketDataContainerRequestBody defines model for CreateBucketDataContainerRequestBody.
type CreateBucketDataContainerRequestBody struct {
	DataDockId openapi_types.UUID `json:"data_dock_id"`
	Name       string             `json:"name"`
}

// CreateBucketFolderRequest defines model for CreateBucketFolderRequest.
type CreateBucketFolderRequest struct {
	Path string `json:"path"`
}

// CreateContextProviderBody Request to create a context provider.
type CreateContextProviderBody struct {
	// Config Configuration JSON based on provider type
	Config  interface{} `json:"config"`
	Enabled *bool       `json:"enabled"`
	Name    string      `json:"name"`

	// ProviderType Provider type: "csv" or "http_api"
	ProviderType        string `json:"provider_type"`
	SyncIntervalSeconds *int32 `json:"sync_interval_seconds"`
}

// CreateContextualRestrictionBody Request to create a contextual restriction.
type CreateContextualRestrictionBody struct {
	DataSelector    interface{} `json:"data_selector"`
	Description     *string     `json:"description"`
	Enabled         *bool       `json:"enabled"`
	Name            string      `json:"name"`
	Priority        *int32      `json:"priority"`
	UserRequirement interface{} `json:"user_requirement"`
}

// CreateCopyPipelineRequest Copy pipeline request: Import API source â†’ S3 destination
type CreateCopyPipelineRequest struct {
	// Destination Copy pipeline destination configuration (S3 bucket)
	Destination CopyDestinationConfig `json:"destination"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline PipelineMetadata `json:"pipeline"`

	// Source Copy pipeline source configuration (Import API)
	Source CopySourceConfig `json:"source"`
}

// CreateDataDockRequestBody defines model for CreateDataDockRequestBody.
type CreateDataDockRequestBody struct {
	ConnectionKind DataDockKindRequest `json:"connection_kind"`
	HarborId       openapi_types.UUID  `json:"harbor_id"`
	Name           string              `json:"name"`
	Slug           string              `json:"slug"`
}

// CreateFakerSchemaRequest defines model for CreateFakerSchemaRequest.
type CreateFakerSchemaRequest struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// CreateFakerTableRequest defines model for CreateFakerTableRequest.
type CreateFakerTableRequest struct {
	Name       string `json:"name"`
	SqlRequest string `json:"sql_request"`
}

// CreateFakerTableStructuredRequest defines model for CreateFakerTableStructuredRequest.
type CreateFakerTableStructuredRequest struct {
	Fields    []FakerTableFields `json:"fields"`
	TableName string             `json:"table_name"`
}

// CreateFileRouterPipelineRequest FileRouter pipeline request
type CreateFileRouterPipelineRequest struct {
	// DefaultRoute Configuration for a FileRouter destination
	// Allows routing to different Data Docks with specific prefixes
	DefaultRoute *DestinationConfig `json:"default_route,omitempty"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline PipelineMetadata `json:"pipeline"`

	// RoutingRules Routing rules: label -> list of destinations
	RoutingRules map[string][]DestinationConfig `json:"routing_rules"`

	// Source FileSorter source configuration (S3 bucket for unsorted files)
	Source FileSorterSourceConfig `json:"source"`
}

// CreateFileSorterRequest FileSorter pipeline request with semantic groupings
type CreateFileSorterRequest struct {
	// Classification Classification configuration for AI processing
	Classification ClassificationConfig `json:"classification"`

	// Destination FileSorter destination configuration (S3 bucket for sorted files)
	Destination FileSorterDestinationConfig `json:"destination"`

	// MetadataStorage Metadata storage configuration (Trino/Iceberg for document metadata)
	MetadataStorage MetadataStorageConfig `json:"metadata_storage"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline PipelineMetadata `json:"pipeline"`

	// Routing FileSorter routing configuration
	Routing FileSorterRoutingConfig `json:"routing"`

	// Source FileSorter source configuration (S3 bucket for unsorted files)
	Source FileSorterSourceConfig `json:"source"`
}

// CreateHarborCrdRequestBody defines model for CreateHarborCrdRequestBody.
type CreateHarborCrdRequestBody struct {
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// CreateIcebergDataContainerRequestBody defines model for CreateIcebergDataContainerRequestBody.
type CreateIcebergDataContainerRequestBody struct {
	DataDockId        openapi_types.UUID `json:"data_dock_id"`
	Name              string             `json:"name"`
	S3Bucket          string             `json:"s3_bucket"`
	StorageDataDockId openapi_types.UUID `json:"storage_data_dock_id"`
}

// CreateIcebergTableMetadataRequest Request to create Iceberg table metadata
type CreateIcebergTableMetadataRequest struct {
	DdlStatement string             `json:"ddl_statement"`
	Description  string             `json:"description"`
	SchemaId     openapi_types.UUID `json:"schema_id"`
	TableName    string             `json:"table_name"`
}

// CreateMedallionSchemaRequest defines model for CreateMedallionSchemaRequest.
type CreateMedallionSchemaRequest struct {
	CdcEnabled  *bool   `json:"cdc_enabled"`
	Description *string `json:"description"`
	Name        string  `json:"name"`
	Tier        *string `json:"tier"`
}

// CreateModelServingRequest defines model for CreateModelServingRequest.
type CreateModelServingRequest struct {
	// DisplayName Human-readable display name
	DisplayName string `json:"display_name"`

	// Gpu GPU count
	Gpu *int32 `json:"gpu,omitempty"`

	// MaxModelLen Maximum model context length (optional, for generation models)
	MaxModelLen *int32 `json:"max_model_len"`

	// Memory Memory request (e.g. "8Gi")
	Memory *string `json:"memory,omitempty"`

	// ModelId Model identifier (e.g. "meta-llama/Llama-3.1-8B-Instruct")
	ModelId string `json:"model_id"`

	// ModelType The type of model being served.
	ModelType ModelType `json:"model_type"`

	// Runtime Runtime engine for serving the model.
	Runtime ModelRuntime `json:"runtime"`
}

// CreateOrganizationRequestBody defines model for CreateOrganizationRequestBody.
type CreateOrganizationRequestBody struct {
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// CreatePipelineRequest defines model for CreatePipelineRequest.
type CreatePipelineRequest struct {
	Input    PipelineInputParameters  `json:"input"`
	Output   PipelineOutputParameters `json:"output"`
	Pipeline PipelineParameters       `json:"pipeline"`
}

// CreatePipelineRequestV2 Discriminated union for pipeline creation requests
type CreatePipelineRequestV2 struct {
	union json.RawMessage
}

// CreatePipelineRequestV20 defines model for .
type CreatePipelineRequestV20 struct {
	// Classification Classification configuration for AI processing
	Classification ClassificationConfig `json:"classification"`

	// Destination FileSorter destination configuration (S3 bucket for sorted files)
	Destination FileSorterDestinationConfig `json:"destination"`

	// MetadataStorage Metadata storage configuration (Trino/Iceberg for document metadata)
	MetadataStorage MetadataStorageConfig `json:"metadata_storage"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline PipelineMetadata `json:"pipeline"`

	// Routing FileSorter routing configuration
	Routing FileSorterRoutingConfig `json:"routing"`

	// Source FileSorter source configuration (S3 bucket for unsorted files)
	Source FileSorterSourceConfig       `json:"source"`
	Type   CreatePipelineRequestV20Type `json:"type"`
}

// CreatePipelineRequestV20Type defines model for CreatePipelineRequestV2.0.Type.
type CreatePipelineRequestV20Type string

// CreatePipelineRequestV21 defines model for .
type CreatePipelineRequestV21 struct {
	// Classification Classification configuration for AI processing
	Classification *ClassificationConfig `json:"classification,omitempty"`

	// MetadataStorage Metadata storage configuration (Trino/Iceberg for document metadata)
	MetadataStorage MetadataStorageConfig `json:"metadata_storage"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline     PipelineMetadata `json:"pipeline"`
	PipelineType PipelineType     `json:"pipeline_type"`

	// Source FileSorter source configuration (S3 bucket for unsorted files)
	Source FileSorterSourceConfig       `json:"source"`
	Type   CreatePipelineRequestV21Type `json:"type"`
}

// CreatePipelineRequestV21Type defines model for CreatePipelineRequestV2.1.Type.
type CreatePipelineRequestV21Type string

// CreatePipelineRequestV22 defines model for .
type CreatePipelineRequestV22 struct {
	// DefaultRoute Configuration for a FileRouter destination
	// Allows routing to different Data Docks with specific prefixes
	DefaultRoute *DestinationConfig `json:"default_route,omitempty"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline PipelineMetadata `json:"pipeline"`

	// RoutingRules Routing rules: label -> list of destinations
	RoutingRules map[string][]DestinationConfig `json:"routing_rules"`

	// Source FileSorter source configuration (S3 bucket for unsorted files)
	Source FileSorterSourceConfig       `json:"source"`
	Type   CreatePipelineRequestV22Type `json:"type"`
}

// CreatePipelineRequestV22Type defines model for CreatePipelineRequestV2.2.Type.
type CreatePipelineRequestV22Type string

// CreatePipelineRequestV23 defines model for .
type CreatePipelineRequestV23 struct {
	// Destination Copy pipeline destination configuration (S3 bucket)
	Destination CopyDestinationConfig `json:"destination"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline PipelineMetadata `json:"pipeline"`

	// Source Copy pipeline source configuration (Import API)
	Source CopySourceConfig             `json:"source"`
	Type   CreatePipelineRequestV23Type `json:"type"`
}

// CreatePipelineRequestV23Type defines model for CreatePipelineRequestV2.3.Type.
type CreatePipelineRequestV23Type string

// CreatePipelineRequestV24 defines model for .
type CreatePipelineRequestV24 struct {
	// Destination Copy pipeline destination configuration (S3 bucket)
	Destination CopyDestinationConfig `json:"destination"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline PipelineMetadata `json:"pipeline"`

	// Source S3 source configuration for S3-to-S3 copy
	Source CopyS3SourceConfig           `json:"source"`
	Type   CreatePipelineRequestV24Type `json:"type"`
}

// CreatePipelineRequestV24Type defines model for CreatePipelineRequestV2.4.Type.
type CreatePipelineRequestV24Type string

// CreateS3CopyPipelineRequest S3-to-S3 copy pipeline request
type CreateS3CopyPipelineRequest struct {
	// Destination Copy pipeline destination configuration (S3 bucket)
	Destination CopyDestinationConfig `json:"destination"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline PipelineMetadata `json:"pipeline"`

	// Source S3 source configuration for S3-to-S3 copy
	Source CopyS3SourceConfig `json:"source"`
}

// CreateSavedQueryRequest defines model for CreateSavedQueryRequest.
type CreateSavedQueryRequest struct {
	DataDockId  openapi_types.UUID `json:"data_dock_id"`
	Description *string            `json:"description"`
	SqlText     string             `json:"sql_text"`
	Tags        *[]string          `json:"tags"`
	Title       string             `json:"title"`
	Visibility  *string            `json:"visibility"`
}

// CreateServiceAccountCrdRequestBody defines model for CreateServiceAccountCrdRequestBody.
type CreateServiceAccountCrdRequestBody struct {
	ClientId    string  `json:"client_id"`
	Description *string `json:"description"`
}

// CreateTableClassificationBody Request to create a table classification.
type CreateTableClassificationBody struct {
	ComplianceTags *[]string          `json:"compliance_tags,omitempty"`
	DataDockId     openapi_types.UUID `json:"data_dock_id"`

	// Sensitivity Sensitivity level for data classification
	Sensitivity SensitivityLevel `json:"sensitivity"`

	// TableFqdn Fully qualified table name: "catalog.schema.table"
	TableFqdn string `json:"table_fqdn"`
}

// CreateTrinoPipelineRequest Trino-based pipeline request (Markitdown, HephaistosPdfeed, Labelizer)
type CreateTrinoPipelineRequest struct {
	// Classification Classification configuration for AI processing
	Classification *ClassificationConfig `json:"classification,omitempty"`

	// MetadataStorage Metadata storage configuration (Trino/Iceberg for document metadata)
	MetadataStorage MetadataStorageConfig `json:"metadata_storage"`

	// Pipeline Pipeline metadata configuration (common to all pipeline types)
	Pipeline     PipelineMetadata `json:"pipeline"`
	PipelineType PipelineType     `json:"pipeline_type"`

	// Source FileSorter source configuration (S3 bucket for unsorted files)
	Source FileSorterSourceConfig `json:"source"`
}

// CreateUser defines model for CreateUser.
type CreateUser struct {
	Email          string              `json:"email"`
	FirstName      string              `json:"first_name"`
	LastName       string              `json:"last_name"`
	OauthId        openapi_types.UUID  `json:"oauth_id"`
	OrganizationId *openapi_types.UUID `json:"organization_id"`
}

// DataContainerOverview A summary of a data container
type DataContainerOverview struct {
	DataDockId openapi_types.UUID `json:"data_dock_id"`
	Id         openapi_types.UUID `json:"id"`
	Kind       string             `json:"kind"`
	Name       string             `json:"name"`
}

// DataDock defines model for DataDock.
type DataDock struct {
	Catalog     *TrinoMetadata     `json:"catalog,omitempty"`
	Description string             `json:"description"`
	HarborId    openapi_types.UUID `json:"harbor_id"`
	Host        string             `json:"host"`
	Id          openapi_types.UUID `json:"id"`

	// InternalHost internal_host and internal_port composes the address to reach the data dock from inside the cluster.
	// This is mainly used for introspection
	InternalHost *string      `json:"internal_host"`
	InternalPort *int32       `json:"internal_port"`
	Kind         DataDockKind `json:"kind"`
	Name         string       `json:"name"`
	OpaUri       *string      `json:"opa_uri"`

	// Port This is i16 to match the sqlx type for port but this should never be negative (constraints are already in place in the db)
	Port                 int32          `json:"port"`
	RefreshInterval      int32          `json:"refresh_interval"`
	RefreshedAt          *time.Time     `json:"refreshed_at"`
	ServiceAccountId     string         `json:"service_account_id"`
	ServiceAccountSecret string         `json:"service_account_secret"`
	Slug                 string         `json:"slug"`
	Status               DataDockStatus `json:"status"`

	// StsRoleArn IAM role ARN for STS AssumeRoleWithWebIdentity (required for Ceph RGW)
	// Format: arn:aws:iam:::role/<role-name>
	StsRoleArn *string `json:"sts_role_arn"`

	// TokenIssuerEndpoint token issuer endpoint is the url to get
	// the token related to the service account
	TokenIssuerEndpoint string `json:"token_issuer_endpoint"`
}

// DataDockKind defines model for DataDockKind.
type DataDockKind struct {
	union json.RawMessage
}

// DataDockKind0 defines model for .
type DataDockKind0 struct {
	Type DataDockKind0Type `json:"type"`
}

// DataDockKind0Type defines model for DataDockKind.0.Type.
type DataDockKind0Type string

// DataDockKind1 defines model for .
type DataDockKind1 struct {
	Content TrinoInternalConfig `json:"content"`
	Type    DataDockKind1Type   `json:"type"`
}

// DataDockKind1Type defines model for DataDockKind.1.Type.
type DataDockKind1Type string

// DataDockKind2 defines model for .
type DataDockKind2 struct {
	Content MinioInternalConfig `json:"content"`
	Type    DataDockKind2Type   `json:"type"`
}

// DataDockKind2Type defines model for DataDockKind.2.Type.
type DataDockKind2Type string

// DataDockKind3 defines model for .
type DataDockKind3 struct {
	Content PostgresInternalConfig `json:"content"`
	Type    DataDockKind3Type      `json:"type"`
}

// DataDockKind3Type defines model for DataDockKind.3.Type.
type DataDockKind3Type string

// DataDockKind4 defines model for .
type DataDockKind4 struct {
	Content CephRgwInternalConfig `json:"content"`
	Type    DataDockKind4Type     `json:"type"`
}

// DataDockKind4Type defines model for DataDockKind.4.Type.
type DataDockKind4Type string

// DataDockKindRequest defines model for DataDockKindRequest.
type DataDockKindRequest struct {
	union json.RawMessage
}

// DataDockKindRequest0 defines model for .
type DataDockKindRequest0 struct {
	Content TrinoConfigRequest       `json:"content"`
	Type    DataDockKindRequest0Type `json:"type"`
}

// DataDockKindRequest0Type defines model for DataDockKindRequest.0.Type.
type DataDockKindRequest0Type string

// DataDockKindRequest1 defines model for .
type DataDockKindRequest1 struct {
	Content TrinoInternalConfig      `json:"content"`
	Type    DataDockKindRequest1Type `json:"type"`
}

// DataDockKindRequest1Type defines model for DataDockKindRequest.1.Type.
type DataDockKindRequest1Type string

// DataDockKindRequest2 defines model for .
type DataDockKindRequest2 struct {
	Content MinioInternalConfig      `json:"content"`
	Type    DataDockKindRequest2Type `json:"type"`
}

// DataDockKindRequest2Type defines model for DataDockKindRequest.2.Type.
type DataDockKindRequest2Type string

// DataDockKindRequest3 defines model for .
type DataDockKindRequest3 struct {
	Content PostgresInternalConfig   `json:"content"`
	Type    DataDockKindRequest3Type `json:"type"`
}

// DataDockKindRequest3Type defines model for DataDockKindRequest.3.Type.
type DataDockKindRequest3Type string

// DataDockKindRequest4 defines model for .
type DataDockKindRequest4 struct {
	Content CephRgwInternalConfig    `json:"content"`
	Type    DataDockKindRequest4Type `json:"type"`
}

// DataDockKindRequest4Type defines model for DataDockKindRequest.4.Type.
type DataDockKindRequest4Type string

// DataDockKindResponse defines model for DataDockKindResponse.
type DataDockKindResponse struct {
	union json.RawMessage
}

// DataDockKindResponse0 defines model for .
type DataDockKindResponse0 struct {
	Content TrinoConfigResponse       `json:"content"`
	Type    DataDockKindResponse0Type `json:"type"`
}

// DataDockKindResponse0Type defines model for DataDockKindResponse.0.Type.
type DataDockKindResponse0Type string

// DataDockKindResponse1 defines model for .
type DataDockKindResponse1 struct {
	Content TrinoInternalConfigResponse `json:"content"`
	Type    DataDockKindResponse1Type   `json:"type"`
}

// DataDockKindResponse1Type defines model for DataDockKindResponse.1.Type.
type DataDockKindResponse1Type string

// DataDockKindResponse2 defines model for .
type DataDockKindResponse2 struct {
	Content MinioInternalConfigResponse `json:"content"`
	Type    DataDockKindResponse2Type   `json:"type"`
}

// DataDockKindResponse2Type defines model for DataDockKindResponse.2.Type.
type DataDockKindResponse2Type string

// DataDockKindResponse3 defines model for .
type DataDockKindResponse3 struct {
	Content PostgresInternalConfigResponse `json:"content"`
	Type    DataDockKindResponse3Type      `json:"type"`
}

// DataDockKindResponse3Type defines model for DataDockKindResponse.3.Type.
type DataDockKindResponse3Type string

// DataDockKindResponse4 defines model for .
type DataDockKindResponse4 struct {
	Content CephRgwInternalConfigResponse `json:"content"`
	Type    DataDockKindResponse4Type     `json:"type"`
}

// DataDockKindResponse4Type defines model for DataDockKindResponse.4.Type.
type DataDockKindResponse4Type string

// DataDockResponseData defines model for DataDockResponseData.
type DataDockResponseData struct {
	ConnectionKind  DataDockKindResponse `json:"connection_kind"`
	Description     string               `json:"description"`
	HarborId        openapi_types.UUID   `json:"harbor_id"`
	Host            string               `json:"host"`
	Id              openapi_types.UUID   `json:"id"`
	Name            string               `json:"name"`
	Port            int32                `json:"port"`
	RefreshInterval int32                `json:"refresh_interval"`
	RefreshedAt     *time.Time           `json:"refreshed_at"`
	Slug            string               `json:"slug"`
	Status          DataDockStatus       `json:"status"`
}

// DataDockSecuritySettingsResponse Response for datadock security settings.
type DataDockSecuritySettingsResponse struct {
	ColumnLabelMatching           bool               `json:"column_label_matching"`
	ContextualRestrictionsEnabled bool               `json:"contextual_restrictions_enabled"`
	CreatedAt                     time.Time          `json:"created_at"`
	DataDockId                    openapi_types.UUID `json:"data_dock_id"`
	OfficeHoursEnabled            *bool              `json:"office_hours_enabled"`
	ReadOnlyMode                  bool               `json:"read_only_mode"`
	RlsEnabledCatalogs            []string           `json:"rls_enabled_catalogs"`
	RlsEnabledSchemas             []string           `json:"rls_enabled_schemas"`
	RlsEnabledTables              []string           `json:"rls_enabled_tables"`
	RlsLabelColumn                string             `json:"rls_label_column"`
	SensitivityEnforcement        bool               `json:"sensitivity_enforcement"`
	TableLabelMatching            bool               `json:"table_label_matching"`
	UpdatedAt                     time.Time          `json:"updated_at"`
}

// DataDockStatus defines model for DataDockStatus.
type DataDockStatus string

// DedupingStrategy defines model for DedupingStrategy.
type DedupingStrategy struct {
	union json.RawMessage
}

// DedupingStrategy0 defines model for .
type DedupingStrategy0 struct {
	Suffix Sha256HashDedupingStrategy `json:"Suffix"`
}

// DestinationConfig Configuration for a FileRouter destination
// Allows routing to different Data Docks with specific prefixes
type DestinationConfig struct {
	// BucketId UUID of the bucket Data Container within the destination data dock
	BucketId openapi_types.UUID `json:"bucket_id"`

	// DataDockId UUID of the destination Data Dock (S3)
	DataDockId openapi_types.UUID `json:"data_dock_id"`

	// Prefix Prefix path within the destination bucket (e.g., "invoices/processed/")
	Prefix string `json:"prefix"`
}

// DownloadServiceAccountResponse defines model for DownloadServiceAccountResponse.
type DownloadServiceAccountResponse struct {
	AuthUri      string `json:"auth_uri"`
	ClientId     string `json:"client_id"`
	ClientSecret string `json:"client_secret"`
	Issuer       string `json:"issuer"`
	TokenUri     string `json:"token_uri"`
}

// EffectiveSecuritySettingsResponse Response for effective security settings.
type EffectiveSecuritySettingsResponse struct {
	ColumnLabelMatching           bool     `json:"column_label_matching"`
	ContextualRestrictionsEnabled bool     `json:"contextual_restrictions_enabled"`
	OfficeHoursEnabled            bool     `json:"office_hours_enabled"`
	OfficeHoursEndUtc             *string  `json:"office_hours_end_utc"`
	OfficeHoursStartUtc           *string  `json:"office_hours_start_utc"`
	ReadOnlyMode                  bool     `json:"read_only_mode"`
	RlsEnabledCatalogs            []string `json:"rls_enabled_catalogs"`
	RlsEnabledSchemas             []string `json:"rls_enabled_schemas"`
	RlsEnabledTables              []string `json:"rls_enabled_tables"`
	RlsLabelColumn                string   `json:"rls_label_column"`
	SensitivityEnforcement        bool     `json:"sensitivity_enforcement"`
	TableLabelMatching            bool     `json:"table_label_matching"`
	ZeroTrustMode                 bool     `json:"zero_trust_mode"`
}

// ExecuteRequest defines model for ExecuteRequest.
type ExecuteRequest struct {
	DataDockId     openapi_types.UUID `json:"data_dock_id"`
	Limit          *int64             `json:"limit"`
	Sql            string             `json:"sql"`
	TimeoutSeconds *int64             `json:"timeout_seconds"`
}

// FakerFieldType defines model for FakerFieldType.
type FakerFieldType struct {
	Category    string  `json:"category"`
	Description string  `json:"description"`
	FieldType   string  `json:"field_type"`
	Generator   *string `json:"generator"`
	Name        string  `json:"name"`
}

// FakerSchemaOverview defines model for FakerSchemaOverview.
type FakerSchemaOverview struct {
	CreatedAt       time.Time          `json:"created_at"`
	DataContainerId openapi_types.UUID `json:"data_container_id"`
	Id              openapi_types.UUID `json:"id"`
	Name            string             `json:"name"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

// FakerTableFieldOptions defines model for FakerTableFieldOptions.
type FakerTableFieldOptions struct {
	Blank *float32 `json:"blank"`
}

// FakerTableFields defines model for FakerTableFields.
type FakerTableFields struct {
	FieldType string                  `json:"field_type"`
	Generator *string                 `json:"generator"`
	Name      string                  `json:"name"`
	Options   *FakerTableFieldOptions `json:"options,omitempty"`
}

// FakerTableOverview defines model for FakerTableOverview.
type FakerTableOverview struct {
	CreatedAt       time.Time          `json:"created_at"`
	DataContainerId openapi_types.UUID `json:"data_container_id"`
	Fields          []FakerTableFields `json:"fields"`
	Id              openapi_types.UUID `json:"id"`
	Name            string             `json:"name"`
	RawSql          *string            `json:"raw_sql"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

// FakerTableTemplate defines model for FakerTableTemplate.
type FakerTableTemplate struct {
	Fields []TemplateFakerField `json:"fields"`
	Name   string               `json:"name"`
}

// FileSorterDestinationConfig FileSorter destination configuration (S3 bucket for sorted files)
type FileSorterDestinationConfig struct {
	// BasePrefix Base prefix for sorted files
	BasePrefix *string `json:"base_prefix"`

	// DataContainerId Data Container ID for the destination bucket (null = use source bucket)
	DataContainerId *openapi_types.UUID `json:"data_container_id"`
}

// FileSorterOutputParameters FileSorter output configuration - combines 3 steps:
// HephaistosPdfeed -> Labelize -> CategoryRouterMetadataAware
type FileSorterOutputParameters struct {
	// DcIcebergId UUID of the Iceberg catalog Data Container
	DcIcebergId openapi_types.UUID `json:"dc_iceberg_id"`

	// DdTrinoInt UUID of the Trino Data Dock for metadata storage
	DdTrinoInt openapi_types.UUID `json:"dd_trino_int"`

	// DestinationBucketId UUID of the destination bucket Data Container for sorted files
	DestinationBucketId *openapi_types.UUID `json:"destination_bucket_id"`

	// DestinationPrefix Destination prefix for sorted files
	DestinationPrefix *string `json:"destination_prefix"`

	// DestinationS3Dd UUID of the destination S3 Data Dock for sorted files
	DestinationS3Dd *openapi_types.UUID `json:"destination_s3_dd"`

	// LabelsYaml Labels for document classification in YAML format.
	// Supports both static and dynamic labels with placeholders.
	//
	// Example:
	// ```yaml
	// - id: facture_eau
	//   type: static
	//   description: "Water utility invoices"
	// - id: travaux
	//   type: dynamic
	//   description: "Construction work documents"
	//   format: "TRAVAUX/{year}/{date}"
	//   placeholders:
	//     - id: year
	//       source: "Extract the year"
	//       format: "YYYY"
	// ```
	LabelsYaml string `json:"labels_yaml"`

	// ModelApiKey Mistral API key for OCR and classification
	ModelApiKey string `json:"model_api_key"`

	// ModelName Model name (e.g., "mistral-medium", "mistral-large-latest")
	ModelName string `json:"model_name"`

	// Router Category router configuration (CategoryRouterMetadataAware step)
	Router CategoryRouterConfig `json:"router"`

	// SourceFileConnectionId Source S3 connection ID for router (references input.dd_minio)
	SourceFileConnectionId *string `json:"source_file_connection_id"`

	// TrinoSchema Trino schema name
	TrinoSchema string `json:"trino_schema"`

	// TrinoTable Trino table name for metadata
	TrinoTable string `json:"trino_table"`

	// UnknownPlaceholderValue Value to use when a placeholder cannot be extracted (default: "unknown")
	UnknownPlaceholderValue *string `json:"unknown_placeholder_value,omitempty"`
}

// FileSorterRoutingConfig FileSorter routing configuration
type FileSorterRoutingConfig struct {
	// DefaultCategory Default category if no label matches
	DefaultCategory *string `json:"default_category"`

	// SourcePrefixRegex Regex to extract prefix from source path (single capture group)
	SourcePrefixRegex *string `json:"source_prefix_regex"`
}

// FileSorterSourceConfig FileSorter source configuration (S3 bucket for unsorted files)
type FileSorterSourceConfig struct {
	// DataContainerId Data Container ID for the source bucket (DataDock is resolved automatically)
	DataContainerId openapi_types.UUID `json:"data_container_id"`

	// FolderPrefix Optional folder prefix within the bucket
	FolderPrefix *string `json:"folder_prefix"`
}

// GetConsoleConfigResponse defines model for GetConsoleConfigResponse.
type GetConsoleConfigResponse struct {
	AppVersion         string `json:"app_version"`
	BifrostApiUrl      string `json:"bifrost_api_url"`
	BifrostSqlEndpoint string `json:"bifrost_sql_endpoint"`

	// ConsoleBaseDomain The base domain for the console (e.g., "localhost" for dev, "hyperfluid.app" for prod).
	ConsoleBaseDomain             string                     `json:"console_base_domain"`
	ConsoleServiceAccountClientId string                     `json:"console_service_account_client_id"`
	FeatureFlags                  []ConsoleConfigFeatureFlag `json:"feature_flags"`
	OidcBaseUrl                   string                     `json:"oidc_base_url"`
	OidcExpectedAudiences         []string                   `json:"oidc_expected_audiences"`
	SapienceApiUrl                string                     `json:"sapience_api_url"`
}

// GetFakerFieldTypesResponse defines model for GetFakerFieldTypesResponse.
type GetFakerFieldTypesResponse struct {
	Data      []FakerFieldType     `json:"data"`
	Templates []FakerTableTemplate `json:"templates"`
}

// GetFakerSchemaResponse defines model for GetFakerSchemaResponse.
type GetFakerSchemaResponse struct {
	Data []FakerSchemaOverview `json:"data"`
}

// GetFakerTableResponse defines model for GetFakerTableResponse.
type GetFakerTableResponse struct {
	Data FakerTableOverview `json:"data"`
}

// GetFakerTablesResponse defines model for GetFakerTablesResponse.
type GetFakerTablesResponse struct {
	Data []FakerTableOverview `json:"data"`
}

// GetRunResponse defines model for GetRunResponse.
type GetRunResponse struct {
	Run PipelineRun `json:"run"`
}

// Harbor A harbor is a collection of [DataDocks](super::datadock::Datadock)
// Each harbor belongs to an [Org](super::org::Org)
// Each harbor has an owner who is a [User](super::user::User)
type Harbor struct {
	Id             openapi_types.UUID  `json:"id"`
	Name           string              `json:"name"`
	OrganizationId openapi_types.UUID  `json:"organization_id"`
	OwnerId        *openapi_types.UUID `json:"owner_id"`
	Slug           string              `json:"slug"`
}

// HfCollumn defines model for HfCollumn.
type HfCollumn struct {
	DataType HfDataType `json:"data_type"`
	Name     string     `json:"name"`
}

// HfDataType defines model for HfDataType.
type HfDataType string

// HfTable defines model for HfTable.
type HfTable struct {
	CatalogName string      `json:"catalog_name"`
	Columns     []HfCollumn `json:"columns"`
	SchemaName  string      `json:"schema_name"`
	TableName   string      `json:"table_name"`
}

// IcebergConnectorDataContainer defines model for IcebergConnectorDataContainer.
type IcebergConnectorDataContainer struct {
	DataDockId      openapi_types.UUID `json:"data_dock_id"`
	Id              openapi_types.UUID `json:"id"`
	Name            string             `json:"name"`
	S3Bucket        string             `json:"s3_bucket"`
	StorageDataDock openapi_types.UUID `json:"storage_data_dock"`
}

// IcebergSchemaMetadata defines model for IcebergSchemaMetadata.
type IcebergSchemaMetadata struct {
	CdcEnabled      bool               `json:"cdc_enabled"`
	CreatedAt       time.Time          `json:"created_at"`
	CreatorId       openapi_types.UUID `json:"creator_id"`
	DataContainerId openapi_types.UUID `json:"data_container_id"`
	Description     *string            `json:"description"`
	Id              openapi_types.UUID `json:"id"`
	Location        string             `json:"location"`
	MedallionTier   string             `json:"medallion_tier"`
	SchemaName      string             `json:"schema_name"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

// IcebergTableMetadata Iceberg table metadata stored in Hyperfluid
type IcebergTableMetadata struct {
	CreatedAt    time.Time          `json:"created_at"`
	CreatorId    openapi_types.UUID `json:"creator_id"`
	DdlStatement string             `json:"ddl_statement"`
	Id           openapi_types.UUID `json:"id"`
	SchemaId     openapi_types.UUID `json:"schema_id"`
	TableName    string             `json:"table_name"`
	UpdatedAt    time.Time          `json:"updated_at"`
}

// IcebergTableResponseData defines model for IcebergTableResponseData.
type IcebergTableResponseData struct {
	CreatedAt       time.Time          `json:"created_at"`
	CreatorId       openapi_types.UUID `json:"creator_id"`
	DataContainerId openapi_types.UUID `json:"data_container_id"`
	DdlStatement    string             `json:"ddl_statement"`
	Id              openapi_types.UUID `json:"id"`
	MedallionTier   string             `json:"medallion_tier"`
	SchemaId        openapi_types.UUID `json:"schema_id"`
	SchemaName      string             `json:"schema_name"`
	TableName       string             `json:"table_name"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

// LabelDefinition Label definition for document classification (Labelize step)
// Supports both static labels (id + description) and dynamic labels with placeholders.
//
// Example YAML format:
// ```yaml
//   - id: facture_eau
//     type: static
//     description: "Water utility invoices"
//   - id: travaux
//     type: dynamic
//     description: "Construction work documents"
//     format: "TRAVAUX/{year}/{date}-{work_name}"
//     placeholders:
//   - id: year
//     source: "Extract the year from the document"
//     format: "YYYY"
//     rules: ["Must be 4 digits"]
//
// ```
type LabelDefinition struct {
	// Category Label category key (e.g., "Factures/Eau", "Contrats/Entretien")
	Category string `json:"category"`

	// Description Human-readable description for LLM classification
	Description string `json:"description"`
}

// ListContextProvidersResponse Response for list of context providers.
type ListContextProvidersResponse struct {
	Providers []ContextProviderResponse `json:"providers"`
}

// ListContextualRestrictionsResponse Response for list of contextual restrictions.
type ListContextualRestrictionsResponse struct {
	Restrictions []ContextualRestrictionResponse `json:"restrictions"`
}

// ListRunsResponse defines model for ListRunsResponse.
type ListRunsResponse struct {
	Runs []PipelineRun `json:"runs"`
}

// ListServiceAccountsResponseData defines model for ListServiceAccountsResponseData.
type ListServiceAccountsResponseData struct {
	ServiceAccounts []ServiceAccount `json:"service_accounts"`
}

// ListTableClassificationsResponse Response for list of table classifications.
type ListTableClassificationsResponse struct {
	Classifications []TableClassificationResponse `json:"classifications"`
}

// ListUserAttributesResponse Response containing a list of user attributes.
type ListUserAttributesResponse struct {
	// Attributes List of attributes in `namespace::value` format.
	Attributes []string `json:"attributes"`
}

// MetadataStorageConfig Metadata storage configuration (Trino/Iceberg for document metadata)
type MetadataStorageConfig struct {
	// DataContainerId Data Container ID for the Iceberg catalog (DataDock is resolved automatically)
	DataContainerId openapi_types.UUID `json:"data_container_id"`

	// SchemaName Trino schema name
	SchemaName string `json:"schema_name"`

	// TableName Trino table name
	TableName string `json:"table_name"`
}

// MinioInternalConfig defines model for MinioInternalConfig.
type MinioInternalConfig struct {
	// StorageSize Storage size in Gigabytes
	StorageSize int32 `json:"storage_size"`
}

// MinioInternalConfigResponse defines model for MinioInternalConfigResponse.
type MinioInternalConfigResponse struct {
	StorageSize string `json:"storage_size"`
}

// ModelConfig Extra configuration for the model serving instance.
type ModelConfig struct {
	// ExtraArgs Extra CLI arguments passed to the runtime
	ExtraArgs *[]string `json:"extraArgs,omitempty"`

	// MaxModelLen Maximum model context length (vLLM --max-model-len)
	MaxModelLen *int32 `json:"maxModelLen"`

	// ServedModelName Served model name override
	ServedModelName *string `json:"servedModelName"`

	// StorageUri Custom storage URI (e.g. s3:// or pvc://)
	StorageUri *string `json:"storageUri"`
}

// ModelResources Resource requests for the model serving instance.
type ModelResources struct {
	// Cpu CPU request (e.g. "2", "4")
	Cpu *string `json:"cpu,omitempty"`

	// Gpu Number of GPUs (0 for CPU-only)
	Gpu *int32 `json:"gpu,omitempty"`

	// Memory Memory request (e.g. "8Gi", "16Gi")
	Memory *string `json:"memory,omitempty"`
}

// ModelRuntime Runtime engine for serving the model.
type ModelRuntime string

// ModelServingPhase Phase of the ModelServing lifecycle.
type ModelServingPhase string

// ModelServingResponse defines model for ModelServingResponse.
type ModelServingResponse struct {
	// Config Extra configuration for the model serving instance.
	Config ModelConfig `json:"config"`

	// DisplayName Human-readable display name
	DisplayName string `json:"display_name"`

	// Endpoint OpenAI-compatible endpoint
	Endpoint *string `json:"endpoint"`

	// ModelId Model identifier
	ModelId string `json:"model_id"`

	// ModelType The type of model being served.
	ModelType ModelType `json:"model_type"`

	// Name CRD resource name
	Name string `json:"name"`

	// Phase Phase of the ModelServing lifecycle.
	Phase *ModelServingPhase `json:"phase,omitempty"`

	// ReadyReplicas Ready replicas
	ReadyReplicas int32 `json:"ready_replicas"`

	// Resources Resource requests for the model serving instance.
	Resources ModelResources `json:"resources"`

	// Runtime Runtime engine for serving the model.
	Runtime ModelRuntime `json:"runtime"`

	// TotalReplicas Total desired replicas
	TotalReplicas int32 `json:"total_replicas"`
}

// ModelType The type of model being served.
type ModelType string

// MultipartPartUrl Presigned URL for a single part in multipart upload
type MultipartPartUrl struct {
	// PartNumber Part number (1-indexed as per S3 API)
	PartNumber int32 `json:"part_number"`

	// UploadUrl Presigned URL for uploading this part
	UploadUrl string `json:"upload_url"`
}

// Org An organization is a collection of [Users](super::user::User) and [DataDocks](super::datadock::DataDock)
type Org struct {
	CreatedAt time.Time          `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Name      string             `json:"name"`
	Slug      string             `json:"slug"`
}

// OrgSecuritySettingsResponse Response for organization security settings.
type OrgSecuritySettingsResponse struct {
	CreatedAt           time.Time          `json:"created_at"`
	OfficeHoursEnabled  bool               `json:"office_hours_enabled"`
	OfficeHoursEndUtc   *string            `json:"office_hours_end_utc"`
	OfficeHoursStartUtc *string            `json:"office_hours_start_utc"`
	OrganizationId      openapi_types.UUID `json:"organization_id"`
	UpdatedAt           time.Time          `json:"updated_at"`
	ZeroTrustMode       bool               `json:"zero_trust_mode"`
}

// OrgUserAttributesResponse Response for organization-wide user attributes (grouped by user).
type OrgUserAttributesResponse struct {
	// Users Map of user_id to their attributes.
	Users []UserAttributesEntry `json:"users"`
}

// PatchModelServingRequest defines model for PatchModelServingRequest.
type PatchModelServingRequest struct {
	// Replicas Target replica count for scaling
	Replicas *int32 `json:"replicas"`
}

// PipelineInputParameters defines model for PipelineInputParameters.
type PipelineInputParameters struct {
	// DcBucketId UUID of the bucket Data Container (not required for Copy pipeline)
	DcBucketId *openapi_types.UUID `json:"dc_bucket_id"`

	// DdMinio UUID of the source MinIO Data Dock (not required for Copy pipeline)
	DdMinio *openapi_types.UUID `json:"dd_minio"`

	// DefaultRoute Configuration for a FileRouter destination
	// Allows routing to different Data Docks with specific prefixes
	DefaultRoute *DestinationConfig `json:"default_route,omitempty"`
	Folder       *string            `json:"folder"`

	// ImportApiKey Copy pipeline: Import API Key (source)
	ImportApiKey *string `json:"import_api_key"`

	// ImportApiUrl Copy pipeline: Import API URL (source)
	ImportApiUrl *string `json:"import_api_url"`

	// RoutingRules FileRouter routing rules: label -> list of destinations
	// Example: {"type::invoice": [DestinationConfig { data_dock_id: "uuid", bucket_id: "uuid", prefix: "invoices/" }]}
	RoutingRules *map[string][]DestinationConfig `json:"routing_rules"`
}

// PipelineMetadata Pipeline metadata configuration (common to all pipeline types)
type PipelineMetadata struct {
	// Enabled Whether the pipeline is enabled (only applies to CronJobs)
	Enabled *bool `json:"enabled,omitempty"`

	// Name Pipeline name
	Name string `json:"name"`

	// OneOff Whether this is a one-off job (true) or a scheduled CronJob (false)
	OneOff *bool `json:"one_off,omitempty"`

	// OrganizationId Organization ID
	OrganizationId openapi_types.UUID `json:"organization_id"`

	// OrganizationSlug Organization slug (used for Keycloak realm)
	OrganizationSlug string `json:"organization_slug"`
}

// PipelineOutputParameters defines model for PipelineOutputParameters.
type PipelineOutputParameters struct {
	union json.RawMessage
}

// PipelineOutputParameters0 defines model for .
type PipelineOutputParameters0 struct {
	// DcIcebergId UUID of the Iceberg catalog Data Container
	DcIcebergId openapi_types.UUID `json:"dc_iceberg_id"`

	// DdTrinoInt UUID of the Trino Data Dock
	DdTrinoInt  openapi_types.UUID            `json:"dd_trino_int"`
	Labels      *map[string]string            `json:"labels"`
	ModelApiKey *string                       `json:"model_api_key"`
	ModelName   *string                       `json:"model_name"`
	TrinoSchema string                        `json:"trino_schema"`
	TrinoTable  string                        `json:"trino_table"`
	Type        PipelineOutputParameters0Type `json:"type"`
}

// PipelineOutputParameters0Type defines model for PipelineOutputParameters.0.Type.
type PipelineOutputParameters0Type string

// PipelineOutputParameters1 defines model for .
type PipelineOutputParameters1 struct {
	Type PipelineOutputParameters1Type `json:"type"`
}

// PipelineOutputParameters1Type defines model for PipelineOutputParameters.1.Type.
type PipelineOutputParameters1Type string

// PipelineOutputParameters2 defines model for .
type PipelineOutputParameters2 struct {
	// DcIcebergId UUID of the Iceberg catalog Data Container
	DcIcebergId openapi_types.UUID `json:"dc_iceberg_id"`

	// DdTrinoInt UUID of the Trino Data Dock for metadata storage
	DdTrinoInt openapi_types.UUID `json:"dd_trino_int"`

	// DestinationBucketId UUID of the destination bucket Data Container for sorted files
	DestinationBucketId *openapi_types.UUID `json:"destination_bucket_id"`

	// DestinationPrefix Destination prefix for sorted files
	DestinationPrefix *string `json:"destination_prefix"`

	// DestinationS3Dd UUID of the destination S3 Data Dock for sorted files
	DestinationS3Dd *openapi_types.UUID `json:"destination_s3_dd"`

	// LabelsYaml Labels for document classification in YAML format.
	// Supports both static and dynamic labels with placeholders.
	//
	// Example:
	// ```yaml
	// - id: facture_eau
	//   type: static
	//   description: "Water utility invoices"
	// - id: travaux
	//   type: dynamic
	//   description: "Construction work documents"
	//   format: "TRAVAUX/{year}/{date}"
	//   placeholders:
	//     - id: year
	//       source: "Extract the year"
	//       format: "YYYY"
	// ```
	LabelsYaml string `json:"labels_yaml"`

	// ModelApiKey Mistral API key for OCR and classification
	ModelApiKey string `json:"model_api_key"`

	// ModelName Model name (e.g., "mistral-medium", "mistral-large-latest")
	ModelName string `json:"model_name"`

	// Router Category router configuration (CategoryRouterMetadataAware step)
	Router CategoryRouterConfig `json:"router"`

	// SourceFileConnectionId Source S3 connection ID for router (references input.dd_minio)
	SourceFileConnectionId *string `json:"source_file_connection_id"`

	// TrinoSchema Trino schema name
	TrinoSchema string `json:"trino_schema"`

	// TrinoTable Trino table name for metadata
	TrinoTable string                        `json:"trino_table"`
	Type       PipelineOutputParameters2Type `json:"type"`

	// UnknownPlaceholderValue Value to use when a placeholder cannot be extracted (default: "unknown")
	UnknownPlaceholderValue *string `json:"unknown_placeholder_value,omitempty"`
}

// PipelineOutputParameters2Type defines model for PipelineOutputParameters.2.Type.
type PipelineOutputParameters2Type string

// PipelineOutputParameters3 defines model for .
type PipelineOutputParameters3 struct {
	// DestinationBucketId UUID of the destination bucket Data Container
	DestinationBucketId openapi_types.UUID `json:"destination_bucket_id"`

	// DestinationDd UUID of the destination MinIO Data Dock
	DestinationDd openapi_types.UUID `json:"destination_dd"`

	// DestinationPrefix Optional prefix path within the destination bucket
	DestinationPrefix *string                       `json:"destination_prefix"`
	Type              PipelineOutputParameters3Type `json:"type"`
}

// PipelineOutputParameters3Type defines model for PipelineOutputParameters.3.Type.
type PipelineOutputParameters3Type string

// PipelineParameters defines model for PipelineParameters.
type PipelineParameters struct {
	// Enabled Whether the pipeline is enabled. Only applies to CronJob pipelines.
	// When false, the CronJob will be suspended. Defaults to true (enabled).
	Enabled *bool              `json:"enabled,omitempty"`
	Name    string             `json:"name"`
	OneOff  bool               `json:"one_off"`
	OrgId   openapi_types.UUID `json:"org_id"`
	OrgSlug string             `json:"org_slug"`
	Type    string             `json:"type"`
}

// PipelineResponseData defines model for PipelineResponseData.
type PipelineResponseData struct {
	CreatedAt time.Time          `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Name      string             `json:"name"`
	OrgId     openapi_types.UUID `json:"org_id"`
	Status    bool               `json:"status"`
	Type      string             `json:"type"`
}

// PipelineRun defines model for PipelineRun.
type PipelineRun struct {
	AverageStepDurationMillis int64              `json:"average_step_duration_millis"`
	CreatedAt                 time.Time          `json:"created_at"`
	Failures                  int64              `json:"failures"`
	FilesProcessed            int64              `json:"files_processed"`
	FilesScanned              int64              `json:"files_scanned"`
	Id                        openapi_types.UUID `json:"id"`
	LastHeartbeatAt           time.Time          `json:"last_heartbeat_at"`
	OrganizationId            openapi_types.UUID `json:"organization_id"`
	PipelineId                openapi_types.UUID `json:"pipeline_id"`
	RunDurationMillis         int64              `json:"run_duration_millis"`
	Status                    PipelineRunStatus  `json:"status"`
	UpdatedAt                 time.Time          `json:"updated_at"`
}

// PipelineRunStatus defines model for PipelineRunStatus.
type PipelineRunStatus string

// PipelineType defines model for PipelineType.
type PipelineType string

// PostgresInternalConfig defines model for PostgresInternalConfig.
type PostgresInternalConfig struct {
	// Cpu CPU limit (e.g., "500m")
	Cpu *string `json:"cpu"`

	// Instances Number of PostgreSQL instances (1=standalone, 2+=HA with replicas)
	Instances int32 `json:"instances"`

	// Memory Memory limit (e.g., "1Gi")
	Memory *string `json:"memory"`

	// StorageSize Storage size in Gigabytes
	StorageSize int32 `json:"storage_size"`
}

// PostgresInternalConfigResponse defines model for PostgresInternalConfigResponse.
type PostgresInternalConfigResponse struct {
	Cpu         *string `json:"cpu"`
	Instances   int32   `json:"instances"`
	Memory      *string `json:"memory"`
	StorageSize string  `json:"storage_size"`
}

// PrepareArchiveImportRequest defines model for PrepareArchiveImportRequest.
type PrepareArchiveImportRequest struct {
	// DestinationDataContainerId The bucket where the zip file will be uploaded
	DestinationDataContainerId openapi_types.UUID `json:"destination_data_container_id"`

	// DestinationFileName The name of the zip file
	DestinationFileName string `json:"destination_file_name"`

	// DestinationFilePath Where the zip file will be stored in the bucket (optional path)
	DestinationFilePath *string `json:"destination_file_path"`

	// FileSize The size of the file in bytes - determines upload strategy
	FileSize int64 `json:"file_size"`
}

// PrepareArchiveImportResponse Response for preparing archive import - either simple upload or multipart
type PrepareArchiveImportResponse struct {
	union json.RawMessage
}

// PrepareArchiveImportResponse0 Simple single PUT upload for files < 100MB
type PrepareArchiveImportResponse0 struct {
	// FilePath The full path where the file will be stored
	FilePath   string                                  `json:"file_path"`
	UploadType PrepareArchiveImportResponse0UploadType `json:"upload_type"`

	// UploadUrl Presigned PUT URL for uploading the file
	UploadUrl string `json:"upload_url"`
}

// PrepareArchiveImportResponse0UploadType defines model for PrepareArchiveImportResponse.0.UploadType.
type PrepareArchiveImportResponse0UploadType string

// PrepareArchiveImportResponse1 Multipart upload for files >= 100MB
type PrepareArchiveImportResponse1 struct {
	// Bucket The bucket name
	Bucket string `json:"bucket"`

	// FilePath The full path where the file will be stored
	FilePath string `json:"file_path"`

	// Key The object key in the bucket
	Key string `json:"key"`

	// PartSize Size of each part in bytes (last part may be smaller)
	PartSize int64 `json:"part_size"`

	// PartUrls Presigned URLs for each part
	PartUrls []MultipartPartUrl `json:"part_urls"`

	// UploadId S3 multipart upload ID
	UploadId   string                                  `json:"upload_id"`
	UploadType PrepareArchiveImportResponse1UploadType `json:"upload_type"`
}

// PrepareArchiveImportResponse1UploadType defines model for PrepareArchiveImportResponse.1.UploadType.
type PrepareArchiveImportResponse1UploadType string

// QueryHistoryEntry defines model for QueryHistoryEntry.
type QueryHistoryEntry struct {
	BytesScanned     *int64              `json:"bytes_scanned"`
	CreatedAt        time.Time           `json:"created_at"`
	DataDockId       openapi_types.UUID  `json:"data_dock_id"`
	ErrorMessage     *string             `json:"error_message"`
	ExecutionTimeMs  *int64              `json:"execution_time_ms"`
	Id               openapi_types.UUID  `json:"id"`
	OrganizationId   openapi_types.UUID  `json:"organization_id"`
	RowsReturned     *int64              `json:"rows_returned"`
	SavedQueryId     *openapi_types.UUID `json:"saved_query_id"`
	ScheduledQueryId *openapi_types.UUID `json:"scheduled_query_id"`
	SqlText          string              `json:"sql_text"`
	StatementType    *string             `json:"statement_type"`
	Status           string              `json:"status"`
	TrinoQueryId     *string             `json:"trino_query_id"`
	UserId           openapi_types.UUID  `json:"user_id"`
}

// QueryResult defines model for QueryResult.
type QueryResult struct {
	Columns         []QueryResultColumn `json:"columns"`
	ExecutionTimeMs int64               `json:"execution_time_ms"`
	HasMore         bool                `json:"has_more"`
	QueryId         openapi_types.UUID  `json:"query_id"`
	Rows            [][]interface{}     `json:"rows"`
	TotalRows       int64               `json:"total_rows"`
	TrinoQueryId    *string             `json:"trino_query_id"`
}

// QueryResultColumn defines model for QueryResultColumn.
type QueryResultColumn struct {
	DataType string `json:"data_type"`
	Name     string `json:"name"`
}

// Ref A reference to a file in a storage bucket
// This reference is created upon scanning a bucket and is used to track the
// status of the file through the pipeline.
type Ref struct {
	Attempts     int64      `json:"attempts"`
	CreatedAt    time.Time  `json:"created_at"`
	ErrorMessage *string    `json:"error_message"`
	Key          string     `json:"key"`
	LockedAt     *time.Time `json:"locked_at"`

	// LockedBy The ID of the pipeline run that locked the reference
	// This is used to track the progress of the pipeline run
	// If the pipeline run is unhealthy (missed a heartbeat), the reference
	// will be unlocked and the pipeline run will be considered failed.
	LockedBy         *openapi_types.UUID `json:"locked_by"`
	PipelineChecksum string              `json:"pipeline_checksum"`
	PipelineId       openapi_types.UUID  `json:"pipeline_id"`
	Status           RefStatus           `json:"status"`
	UpdatedAt        time.Time           `json:"updated_at"`
}

// RefStatus defines model for RefStatus.
type RefStatus string

// RefreshDataDocksResponse defines model for RefreshDataDocksResponse.
type RefreshDataDocksResponse struct {
	Message        string `json:"message"`
	RefreshedCount int32  `json:"refreshed_count"`
	TotalCount     int32  `json:"total_count"`
}

// ResultsPage defines model for ResultsPage.
type ResultsPage struct {
	HasMore   bool            `json:"has_more"`
	Rows      [][]interface{} `json:"rows"`
	TotalRows int64           `json:"total_rows"`
}

// Role defines model for Role.
type Role struct {
	Color          *string            `json:"color"`
	CreatedAt      time.Time          `json:"created_at"`
	Description    *string            `json:"description"`
	Id             openapi_types.UUID `json:"id"`
	IsSystem       bool               `json:"is_system"`
	Name           string             `json:"name"`
	OrganizationId openapi_types.UUID `json:"organization_id"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

// S3OutputParameters defines model for S3OutputParameters.
type S3OutputParameters = map[string]interface{}

// SavedQuery defines model for SavedQuery.
type SavedQuery struct {
	CreatedAt      time.Time          `json:"created_at"`
	CreatedBy      openapi_types.UUID `json:"created_by"`
	DataDockId     openapi_types.UUID `json:"data_dock_id"`
	Description    *string            `json:"description"`
	Id             openapi_types.UUID `json:"id"`
	OrganizationId openapi_types.UUID `json:"organization_id"`
	SqlText        string             `json:"sql_text"`
	Tags           []string           `json:"tags"`
	Title          string             `json:"title"`
	UpdatedAt      time.Time          `json:"updated_at"`
	Visibility     string             `json:"visibility"`
}

// SensitivityLevel Sensitivity level for data classification
type SensitivityLevel string

// ServiceAccount defines model for ServiceAccount.
type ServiceAccount struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description"`

	// IamSaClientId The client_id of the Keycloak client.
	IamSaClientId string `json:"iam_sa_client_id"`

	// IamSaCredentialsPath The secret path in the secret store for the service account credentials.
	IamSaCredentialsPath string `json:"iam_sa_credentials_path"`

	// IamSaId This is the storage ID of the Keycloak client NOT the client_id.
	IamSaId        openapi_types.UUID `json:"iam_sa_id"`
	Id             openapi_types.UUID `json:"id"`
	Name           string             `json:"name"`
	OrganizationId openapi_types.UUID `json:"organization_id"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

// SetUserAttributesRequest Request to set all attributes for a user (replaces existing).
type SetUserAttributesRequest struct {
	// Attributes List of attributes in `namespace::value` format.
	// Example: `["region::occitanie", "department::sales"]`
	Attributes []string `json:"attributes"`
}

// Sha256HashDedupingStrategy defines model for Sha256HashDedupingStrategy.
type Sha256HashDedupingStrategy struct {
	// Flatten Whether to flatten directory structure (true) or preserve it (false)
	Flatten bool `json:"flatten"`

	// Length Number of characters from SHA256 hash to use as suffix
	Length int `json:"length"`
}

// TableClassificationResponse Response for a table classification.
type TableClassificationResponse struct {
	AiConfidence   *float32            `json:"ai_confidence"`
	AiGenerated    bool                `json:"ai_generated"`
	AiReasoning    *string             `json:"ai_reasoning"`
	ClassifiedAt   time.Time           `json:"classified_at"`
	ClassifiedBy   *openapi_types.UUID `json:"classified_by"`
	ComplianceTags []string            `json:"compliance_tags"`
	CreatedAt      time.Time           `json:"created_at"`
	DataDockId     openapi_types.UUID  `json:"data_dock_id"`
	Id             openapi_types.UUID  `json:"id"`
	OrganizationId openapi_types.UUID  `json:"organization_id"`

	// Sensitivity Sensitivity level for data classification
	Sensitivity SensitivityLevel `json:"sensitivity"`
	TableFqdn   string           `json:"table_fqdn"`
	UpdatedAt   time.Time        `json:"updated_at"`
}

// TableColumnResponse defines model for TableColumnResponse.
type TableColumnResponse struct {
	DataType string `json:"data_type"`
	Name     string `json:"name"`
}

// TableDataProductResponse defines model for TableDataProductResponse.
type TableDataProductResponse struct {
	CatalogName   string                `json:"catalog_name"`
	ColumnCount   int32                 `json:"column_count"`
	Columns       []TableColumnResponse `json:"columns"`
	DataDockHost  string                `json:"data_dock_host"`
	DataDockId    string                `json:"data_dock_id"`
	DataDockName  string                `json:"data_dock_name"`
	DataDockPort  int32                 `json:"data_dock_port"`
	DataDockType  string                `json:"data_dock_type"`
	Id            string                `json:"id"`
	LastRefreshed *time.Time            `json:"last_refreshed"`
	SchemaName    string                `json:"schema_name"`
	Status        string                `json:"status"`
	TableName     string                `json:"table_name"`
}

// TemplateFakerField defines model for TemplateFakerField.
type TemplateFakerField struct {
	FieldType string  `json:"field_type"`
	Generator *string `json:"generator"`
	Name      string  `json:"name"`
	TypeName  string  `json:"type_name"`
}

// TrinoCatalog defines model for TrinoCatalog.
type TrinoCatalog struct {
	CatalogName string        `json:"catalog_name"`
	Schemas     []TrinoSchema `json:"schemas"`
}

// TrinoConfigRequest defines model for TrinoConfigRequest.
type TrinoConfigRequest struct {
	Host                 string `json:"host"`
	Port                 int32  `json:"port"`
	ServiceAccountId     string `json:"service_account_id"`
	ServiceAccountSecret string `json:"service_account_secret"`
	TokenIssuerEndpoint  string `json:"token_issuer_endpoint"`
}

// TrinoConfigResponse defines model for TrinoConfigResponse.
type TrinoConfigResponse struct {
	ServiceAccountId     string `json:"service_account_id"`
	ServiceAccountSecret string `json:"service_account_secret"`
	TokenIssuerEndpoint  string `json:"token_issuer_endpoint"`
}

// TrinoInternalConfig defines model for TrinoInternalConfig.
type TrinoInternalConfig struct {
	CoordinatorCpu        *string            `json:"coordinator_cpu"`
	CoordinatorMemory     *string            `json:"coordinator_memory"`
	HashPartitionCount    *int32             `json:"hash_partition_count"`
	MaxMemoryPerNode      *string            `json:"max_memory_per_node"`
	QueryMaxExecutionTime *string            `json:"query_max_execution_time"`
	QueryMaxMemory        *string            `json:"query_max_memory"`
	TaskConcurrency       *int32             `json:"task_concurrency"`
	WorkerAutoScaling     *WorkerAutoScaling `json:"worker_auto_scaling,omitempty"`
	WorkerCpu             *string            `json:"worker_cpu"`
	WorkerMemory          *string            `json:"worker_memory"`
	WorkerReplicas        int32              `json:"worker_replicas"`
}

// TrinoInternalConfigResponse defines model for TrinoInternalConfigResponse.
type TrinoInternalConfigResponse struct {
	CoordinatorCpu        *string                    `json:"coordinator_cpu"`
	CoordinatorMemory     *string                    `json:"coordinator_memory"`
	HashPartitionCount    *int32                     `json:"hash_partition_count"`
	MaxMemoryPerNode      *string                    `json:"max_memory_per_node"`
	QueryMaxExecutionTime *string                    `json:"query_max_execution_time"`
	QueryMaxMemory        *string                    `json:"query_max_memory"`
	TaskConcurrency       *int32                     `json:"task_concurrency"`
	WorkerAutoScaling     *WorkerAutoScalingResponse `json:"worker_auto_scaling,omitempty"`
	WorkerCpu             *string                    `json:"worker_cpu"`
	WorkerMemory          *string                    `json:"worker_memory"`
	WorkerReplicas        int32                      `json:"worker_replicas"`
}

// TrinoMetadata defines model for TrinoMetadata.
type TrinoMetadata struct {
	Catalogs []TrinoCatalog `json:"catalogs"`
}

// TrinoOutputParameters defines model for TrinoOutputParameters.
type TrinoOutputParameters struct {
	// DcIcebergId UUID of the Iceberg catalog Data Container
	DcIcebergId openapi_types.UUID `json:"dc_iceberg_id"`

	// DdTrinoInt UUID of the Trino Data Dock
	DdTrinoInt  openapi_types.UUID `json:"dd_trino_int"`
	Labels      *map[string]string `json:"labels"`
	ModelApiKey *string            `json:"model_api_key"`
	ModelName   *string            `json:"model_name"`
	TrinoSchema string             `json:"trino_schema"`
	TrinoTable  string             `json:"trino_table"`
}

// TrinoSchema defines model for TrinoSchema.
type TrinoSchema struct {
	SchemaName string    `json:"schema_name"`
	Tables     []HfTable `json:"tables"`
}

// UnifiedCatalogResponse defines model for UnifiedCatalogResponse.
type UnifiedCatalogResponse struct {
	ByCatalog      map[string][]string                 `json:"by_catalog"`
	ByDataDock     map[string][]string                 `json:"by_data_dock"`
	BySchema       map[string][]string                 `json:"by_schema"`
	DataDockCounts map[string]int32                    `json:"data_dock_counts"`
	LastUpdated    time.Time                           `json:"last_updated"`
	SearchIndex    map[string][]string                 `json:"search_index"`
	Tables         map[string]TableDataProductResponse `json:"tables"`
	TotalCount     int32                               `json:"total_count"`
}

// UpdateContextProviderBody Request to update a context provider.
type UpdateContextProviderBody struct {
	Config              interface{} `json:"config,omitempty"`
	Enabled             *bool       `json:"enabled"`
	Name                *string     `json:"name"`
	SyncIntervalSeconds *int32      `json:"sync_interval_seconds"`
}

// UpdateContextualRestrictionBody Request to update a contextual restriction.
type UpdateContextualRestrictionBody struct {
	DataSelector    interface{} `json:"data_selector,omitempty"`
	Description     *string     `json:"description"`
	Enabled         *bool       `json:"enabled"`
	Name            *string     `json:"name"`
	Priority        *int32      `json:"priority"`
	UserRequirement interface{} `json:"user_requirement,omitempty"`
}

// UpdateDataDockSecuritySettingsBody Request to update datadock security settings.
type UpdateDataDockSecuritySettingsBody struct {
	ColumnLabelMatching           *bool `json:"column_label_matching"`
	ContextualRestrictionsEnabled *bool `json:"contextual_restrictions_enabled"`

	// OfficeHoursOverride Office hours override: "inherit", "enabled", or "disabled"
	OfficeHoursOverride    *string   `json:"office_hours_override"`
	ReadOnlyMode           *bool     `json:"read_only_mode"`
	RlsEnabledCatalogs     *[]string `json:"rls_enabled_catalogs"`
	RlsEnabledSchemas      *[]string `json:"rls_enabled_schemas"`
	RlsEnabledTables       *[]string `json:"rls_enabled_tables"`
	RlsLabelColumn         *string   `json:"rls_label_column"`
	SensitivityEnforcement *bool     `json:"sensitivity_enforcement"`
	TableLabelMatching     *bool     `json:"table_label_matching"`
}

// UpdateFakerTableRequest defines model for UpdateFakerTableRequest.
type UpdateFakerTableRequest struct {
	Fields []FakerTableFields `json:"fields"`
}

// UpdateOrgSecuritySettingsBody Request to update organization security settings.
type UpdateOrgSecuritySettingsBody struct {
	OfficeHoursEnabled  *bool   `json:"office_hours_enabled"`
	OfficeHoursEndUtc   *string `json:"office_hours_end_utc"`
	OfficeHoursStartUtc *string `json:"office_hours_start_utc"`
	ZeroTrustMode       *bool   `json:"zero_trust_mode"`
}

// UpdateRefRequest defines model for UpdateRefRequest.
type UpdateRefRequest struct {
	Attempts         int64              `json:"attempts"`
	ErrorMessage     *string            `json:"error_message"`
	Key              string             `json:"key"`
	LockedAt         *time.Time         `json:"locked_at"`
	PipelineChecksum string             `json:"pipeline_checksum"`
	PipelineId       openapi_types.UUID `json:"pipeline_id"`
	Status           RefStatus          `json:"status"`
}

// UpdateSavedQueryRequest defines model for UpdateSavedQueryRequest.
type UpdateSavedQueryRequest struct {
	Description *string   `json:"description"`
	SqlText     *string   `json:"sql_text"`
	Tags        *[]string `json:"tags"`
	Title       *string   `json:"title"`
	Visibility  *string   `json:"visibility"`
}

// UpdateServiceAccountCrdRequestBody defines model for UpdateServiceAccountCrdRequestBody.
type UpdateServiceAccountCrdRequestBody struct {
	Description *string `json:"description"`
}

// UpdateTableClassificationBody Request to update a table classification.
type UpdateTableClassificationBody struct {
	ComplianceTags *[]string `json:"compliance_tags"`

	// Sensitivity Sensitivity level for data classification
	Sensitivity *SensitivityLevel `json:"sensitivity,omitempty"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time          `json:"created_at"`
	Email     string             `json:"email"`
	FirstName string             `json:"first_name"`
	Id        openapi_types.UUID `json:"id"`
	LastName  string             `json:"last_name"`
	OauthId   string             `json:"oauth_id"`
}

// UserAttributesEntry Entry for a single user's attributes.
type UserAttributesEntry struct {
	// Attributes List of attributes in `namespace::value` format.
	Attributes []string `json:"attributes"`

	// UserId User ID.
	UserId openapi_types.UUID `json:"user_id"`
}

// UserContextResponse Response for user context.
type UserContextResponse struct {
	// AttributeSources Maps attribute names to the provider name that supplied them.
	AttributeSources map[string]string `json:"attribute_sources"`
	Attributes       interface{}       `json:"attributes"`
	UserId           string            `json:"user_id"`
}

// UserWithRoles defines model for UserWithRoles.
type UserWithRoles struct {
	CreatedAt time.Time          `json:"created_at"`
	Email     string             `json:"email"`
	FirstName string             `json:"first_name"`
	Id        openapi_types.UUID `json:"id"`
	LastName  string             `json:"last_name"`
	OauthId   string             `json:"oauth_id"`
	Roles     []Role             `json:"roles"`
}

// WorkerAutoScaling defines model for WorkerAutoScaling.
type WorkerAutoScaling struct {
	Enabled                 *bool  `json:"enabled,omitempty"`
	MaxReplicas             *int32 `json:"max_replicas,omitempty"`
	MinReplicas             *int32 `json:"min_replicas,omitempty"`
	TargetCpuUtilization    *int32 `json:"target_cpu_utilization,omitempty"`
	TargetMemoryUtilization *int32 `json:"target_memory_utilization"`
}

// WorkerAutoScalingResponse defines model for WorkerAutoScalingResponse.
type WorkerAutoScalingResponse struct {
	Enabled                 bool   `json:"enabled"`
	MaxReplicas             int32  `json:"max_replicas"`
	MinReplicas             int32  `json:"min_replicas"`
	TargetCpuUtilization    int32  `json:"target_cpu_utilization"`
	TargetMemoryUtilization *int32 `json:"target_memory_utilization"`
}

// DeleteBucketFileParams defines parameters for DeleteBucketFile.
type DeleteBucketFileParams struct {
	Path string `form:"path" json:"path"`
}

// ListBucketFilesParams defines parameters for ListBucketFiles.
type ListBucketFilesParams struct {
	Path *string `form:"path,omitempty" json:"path,omitempty"`
}

// DownloadBucketFileParams defines parameters for DownloadBucketFile.
type DownloadBucketFileParams struct {
	Path string `form:"path" json:"path"`
}

// ListArchiveOperationsParams defines parameters for ListArchiveOperations.
type ListArchiveOperationsParams struct {
	Limit  *int64 `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`
}

// DownloadArchiveOperationParams defines parameters for DownloadArchiveOperation.
type DownloadArchiveOperationParams struct {
	// ExpiresIn URL expiration time in seconds (default: 3600, max: 86400)
	ExpiresIn *int64 `form:"expires_in,omitempty" json:"expires_in,omitempty"`
}

// ListOrganizationsParams defines parameters for ListOrganizations.
type ListOrganizationsParams struct {
	Name   *string `form:"name,omitempty" json:"name,omitempty"`
	Slug   *string `form:"slug,omitempty" json:"slug,omitempty"`
	Limit  *int64  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int64  `form:"offset,omitempty" json:"offset,omitempty"`
}

// CheckOrganizationNameAvailabilityParams defines parameters for CheckOrganizationNameAvailability.
type CheckOrganizationNameAvailabilityParams struct {
	Slug string `form:"slug" json:"slug"`
}

// ListHarborsParams defines parameters for ListHarbors.
type ListHarborsParams struct {
	Name   *string `form:"name,omitempty" json:"name,omitempty"`
	Slug   *string `form:"slug,omitempty" json:"slug,omitempty"`
	Limit  *int64  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int64  `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListContextualRestrictionsHandlerParams defines parameters for ListContextualRestrictionsHandler.
type ListContextualRestrictionsHandlerParams struct {
	// DataDockId Filter by DataDock ID
	DataDockId *openapi_types.UUID `form:"data_dock_id,omitempty" json:"data_dock_id,omitempty"`
}

// CreateContextualRestrictionHandlerParams defines parameters for CreateContextualRestrictionHandler.
type CreateContextualRestrictionHandlerParams struct {
	// DataDockId DataDock ID (optional for org-level)
	DataDockId *openapi_types.UUID `form:"data_dock_id,omitempty" json:"data_dock_id,omitempty"`
}

// ListServiceAccountsHandlerParams defines parameters for ListServiceAccountsHandler.
type ListServiceAccountsHandlerParams struct {
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// ListRefsParams defines parameters for ListRefs.
type ListRefsParams struct {
	PipelineId       *openapi_types.UUID `form:"pipeline_id,omitempty" json:"pipeline_id,omitempty"`
	PipelineChecksum *string             `form:"pipeline_checksum,omitempty" json:"pipeline_checksum,omitempty"`
	Status           *RefStatus          `form:"status,omitempty" json:"status,omitempty"`
	Key              *string             `form:"key,omitempty" json:"key,omitempty"`
	UpdatedAtBefore  *time.Time          `form:"updated_at_before,omitempty" json:"updated_at_before,omitempty"`
	UpdatedAtAfter   *time.Time          `form:"updated_at_after,omitempty" json:"updated_at_after,omitempty"`

	// Lock Whether to lock the references listed
	Lock     *bool               `form:"lock,omitempty" json:"lock,omitempty"`
	LockedBy *openapi_types.UUID `form:"locked_by,omitempty" json:"locked_by,omitempty"`
	Limit    *int64              `form:"limit,omitempty" json:"limit,omitempty"`
	Offset   *int64              `form:"offset,omitempty" json:"offset,omitempty"`
}

// CancelQueryHandlerParams defines parameters for CancelQueryHandler.
type CancelQueryHandlerParams struct {
	// DataDockId Data Dock ID
	DataDockId openapi_types.UUID `form:"data_dock_id" json:"data_dock_id"`
}

// GetHistoryHandlerParams defines parameters for GetHistoryHandler.
type GetHistoryHandlerParams struct {
	// DataDockId Filter by Data Dock
	DataDockId *openapi_types.UUID `form:"data_dock_id,omitempty" json:"data_dock_id,omitempty"`

	// Status Filter: running, completed, failed, cancelled
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// StatementType Filter: SELECT, INSERT, CTAS, DDL
	StatementType *string `form:"statement_type,omitempty" json:"statement_type,omitempty"`

	// Search Search in SQL text
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Page Page number (default 0)
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Items per page (default 50, max 200)
	PerPage *int64 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ListSavedQueriesHandlerParams defines parameters for ListSavedQueriesHandler.
type ListSavedQueriesHandlerParams struct {
	// DataDockId Filter by Data Dock
	DataDockId *openapi_types.UUID `form:"data_dock_id,omitempty" json:"data_dock_id,omitempty"`

	// Visibility Filter: private or team
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty"`

	// Search Search in title/description
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Mine Only my queries
	Mine *bool `form:"mine,omitempty" json:"mine,omitempty"`
}

// GetResultsHandlerParams defines parameters for GetResultsHandler.
type GetResultsHandlerParams struct {
	// Offset Row offset (default 0)
	Offset *int64 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Number of rows (default 500)
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetUnifiedCatalogParams defines parameters for GetUnifiedCatalog.
type GetUnifiedCatalogParams struct {
	// HarborId Optional harbor ID to filter data docks by environment
	HarborId *openapi_types.UUID `form:"harbor_id,omitempty" json:"harbor_id,omitempty"`
}

// UpdateContextProviderHandlerJSONRequestBody defines body for UpdateContextProviderHandler for application/json ContentType.
type UpdateContextProviderHandlerJSONRequestBody = UpdateContextProviderBody

// UpdateContextualRestrictionHandlerJSONRequestBody defines body for UpdateContextualRestrictionHandler for application/json ContentType.
type UpdateContextualRestrictionHandlerJSONRequestBody = UpdateContextualRestrictionBody

// CreateBucketDataContainerJSONRequestBody defines body for CreateBucketDataContainer for application/json ContentType.
type CreateBucketDataContainerJSONRequestBody = CreateBucketDataContainerRequestBody

// CreateBucketFolderJSONRequestBody defines body for CreateBucketFolder for application/json ContentType.
type CreateBucketFolderJSONRequestBody = CreateBucketFolderRequest

// CreateFakerSchemaJSONRequestBody defines body for CreateFakerSchema for application/json ContentType.
type CreateFakerSchemaJSONRequestBody = CreateFakerSchemaRequest

// CreateFakerTableJSONRequestBody defines body for CreateFakerTable for application/json ContentType.
type CreateFakerTableJSONRequestBody = CreateFakerTableRequest

// CreateFakerTableStructuredJSONRequestBody defines body for CreateFakerTableStructured for application/json ContentType.
type CreateFakerTableStructuredJSONRequestBody = CreateFakerTableStructuredRequest

// UpdateFakerTableJSONRequestBody defines body for UpdateFakerTable for application/json ContentType.
type UpdateFakerTableJSONRequestBody = UpdateFakerTableRequest

// CreateIcebergDataContainerJSONRequestBody defines body for CreateIcebergDataContainer for application/json ContentType.
type CreateIcebergDataContainerJSONRequestBody = CreateIcebergDataContainerRequestBody

// CreateSchemaJSONRequestBody defines body for CreateSchema for application/json ContentType.
type CreateSchemaJSONRequestBody = CreateMedallionSchemaRequest

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = CreateIcebergTableMetadataRequest

// CloneTableJSONRequestBody defines body for CloneTable for application/json ContentType.
type CloneTableJSONRequestBody = CloneIcebergTableRequestBody

// CreateDataDockCrdJSONRequestBody defines body for CreateDataDockCrd for application/json ContentType.
type CreateDataDockCrdJSONRequestBody = CreateDataDockRequestBody

// ArchiveExportDataContainerJSONRequestBody defines body for ArchiveExportDataContainer for application/json ContentType.
type ArchiveExportDataContainerJSONRequestBody = ArchiveExportRequest

// ArchiveImportDataContainerJSONRequestBody defines body for ArchiveImportDataContainer for application/json ContentType.
type ArchiveImportDataContainerJSONRequestBody = ArchiveImportRequest

// AbortMultipartUploadJSONRequestBody defines body for AbortMultipartUpload for application/json ContentType.
type AbortMultipartUploadJSONRequestBody = AbortMultipartUploadRequest

// CompleteMultipartUploadJSONRequestBody defines body for CompleteMultipartUpload for application/json ContentType.
type CompleteMultipartUploadJSONRequestBody = CompleteMultipartUploadRequest

// PrepareArchiveImportJSONRequestBody defines body for PrepareArchiveImport for application/json ContentType.
type PrepareArchiveImportJSONRequestBody = PrepareArchiveImportRequest

// UpdateDataDockSecuritySettingsHandlerJSONRequestBody defines body for UpdateDataDockSecuritySettingsHandler for application/json ContentType.
type UpdateDataDockSecuritySettingsHandlerJSONRequestBody = UpdateDataDockSecuritySettingsBody

// CreateOrganizationCrdJSONRequestBody defines body for CreateOrganizationCrd for application/json ContentType.
type CreateOrganizationCrdJSONRequestBody = CreateOrganizationRequestBody

// CreateApiKeyJSONRequestBody defines body for CreateApiKey for application/json ContentType.
type CreateApiKeyJSONRequestBody = CreateApiKeyRequest

// CreateHarborCrdJSONRequestBody defines body for CreateHarborCrd for application/json ContentType.
type CreateHarborCrdJSONRequestBody = CreateHarborCrdRequestBody

// CreateModelServingJSONRequestBody defines body for CreateModelServing for application/json ContentType.
type CreateModelServingJSONRequestBody = CreateModelServingRequest

// PatchModelServingJSONRequestBody defines body for PatchModelServing for application/json ContentType.
type PatchModelServingJSONRequestBody = PatchModelServingRequest

// CreateServiceAccountCrdJSONRequestBody defines body for CreateServiceAccountCrd for application/json ContentType.
type CreateServiceAccountCrdJSONRequestBody = CreateServiceAccountCrdRequestBody

// UpdateServiceAccountCrdJSONRequestBody defines body for UpdateServiceAccountCrd for application/json ContentType.
type UpdateServiceAccountCrdJSONRequestBody = UpdateServiceAccountCrdRequestBody

// AddUserToOrganizationJSONRequestBody defines body for AddUserToOrganization for application/json ContentType.
type AddUserToOrganizationJSONRequestBody = AddUser

// AddUserAttributeHandlerJSONRequestBody defines body for AddUserAttributeHandler for application/json ContentType.
type AddUserAttributeHandlerJSONRequestBody = AddUserAttributeRequest

// SetUserAttributesHandlerJSONRequestBody defines body for SetUserAttributesHandler for application/json ContentType.
type SetUserAttributesHandlerJSONRequestBody = SetUserAttributesRequest

// CreateContextProviderHandlerJSONRequestBody defines body for CreateContextProviderHandler for application/json ContentType.
type CreateContextProviderHandlerJSONRequestBody = CreateContextProviderBody

// CreateContextualRestrictionHandlerJSONRequestBody defines body for CreateContextualRestrictionHandler for application/json ContentType.
type CreateContextualRestrictionHandlerJSONRequestBody = CreateContextualRestrictionBody

// UpdateOrgSecuritySettingsHandlerJSONRequestBody defines body for UpdateOrgSecuritySettingsHandler for application/json ContentType.
type UpdateOrgSecuritySettingsHandlerJSONRequestBody = UpdateOrgSecuritySettingsBody

// CreateTableClassificationHandlerJSONRequestBody defines body for CreateTableClassificationHandler for application/json ContentType.
type CreateTableClassificationHandlerJSONRequestBody = CreateTableClassificationBody

// AiClassifyHandlerJSONRequestBody defines body for AiClassifyHandler for application/json ContentType.
type AiClassifyHandlerJSONRequestBody = AiClassifyRequestBody

// UpdateTableClassificationHandlerJSONRequestBody defines body for UpdateTableClassificationHandler for application/json ContentType.
type UpdateTableClassificationHandlerJSONRequestBody = UpdateTableClassificationBody

// CreatePipelineJSONRequestBody defines body for CreatePipeline for application/json ContentType.
type CreatePipelineJSONRequestBody = CreatePipelineRequest

// CountRefsJSONRequestBody defines body for CountRefs for application/json ContentType.
type CountRefsJSONRequestBody = CountRefRequest

// UpdateRefJSONRequestBody defines body for UpdateRef for application/json ContentType.
type UpdateRefJSONRequestBody = UpdateRefRequest

// ExecuteQueryHandlerJSONRequestBody defines body for ExecuteQueryHandler for application/json ContentType.
type ExecuteQueryHandlerJSONRequestBody = ExecuteRequest

// CreateSavedQueryHandlerJSONRequestBody defines body for CreateSavedQueryHandler for application/json ContentType.
type CreateSavedQueryHandlerJSONRequestBody = CreateSavedQueryRequest

// UpdateSavedQueryHandlerJSONRequestBody defines body for UpdateSavedQueryHandler for application/json ContentType.
type UpdateSavedQueryHandlerJSONRequestBody = UpdateSavedQueryRequest

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = CreateUser

// CreatePipelineV2JSONRequestBody defines body for CreatePipelineV2 for application/json ContentType.
type CreatePipelineV2JSONRequestBody = CreatePipelineRequestV2

// AsCreatePipelineRequestV20 returns the union data inside the CreatePipelineRequestV2 as a CreatePipelineRequestV20
func (t CreatePipelineRequestV2) AsCreatePipelineRequestV20() (CreatePipelineRequestV20, error) {
	var body CreatePipelineRequestV20
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePipelineRequestV20 overwrites any union data inside the CreatePipelineRequestV2 as the provided CreatePipelineRequestV20
func (t *CreatePipelineRequestV2) FromCreatePipelineRequestV20(v CreatePipelineRequestV20) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePipelineRequestV20 performs a merge with any union data inside the CreatePipelineRequestV2, using the provided CreatePipelineRequestV20
func (t *CreatePipelineRequestV2) MergeCreatePipelineRequestV20(v CreatePipelineRequestV20) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreatePipelineRequestV21 returns the union data inside the CreatePipelineRequestV2 as a CreatePipelineRequestV21
func (t CreatePipelineRequestV2) AsCreatePipelineRequestV21() (CreatePipelineRequestV21, error) {
	var body CreatePipelineRequestV21
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePipelineRequestV21 overwrites any union data inside the CreatePipelineRequestV2 as the provided CreatePipelineRequestV21
func (t *CreatePipelineRequestV2) FromCreatePipelineRequestV21(v CreatePipelineRequestV21) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePipelineRequestV21 performs a merge with any union data inside the CreatePipelineRequestV2, using the provided CreatePipelineRequestV21
func (t *CreatePipelineRequestV2) MergeCreatePipelineRequestV21(v CreatePipelineRequestV21) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreatePipelineRequestV22 returns the union data inside the CreatePipelineRequestV2 as a CreatePipelineRequestV22
func (t CreatePipelineRequestV2) AsCreatePipelineRequestV22() (CreatePipelineRequestV22, error) {
	var body CreatePipelineRequestV22
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePipelineRequestV22 overwrites any union data inside the CreatePipelineRequestV2 as the provided CreatePipelineRequestV22
func (t *CreatePipelineRequestV2) FromCreatePipelineRequestV22(v CreatePipelineRequestV22) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePipelineRequestV22 performs a merge with any union data inside the CreatePipelineRequestV2, using the provided CreatePipelineRequestV22
func (t *CreatePipelineRequestV2) MergeCreatePipelineRequestV22(v CreatePipelineRequestV22) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreatePipelineRequestV23 returns the union data inside the CreatePipelineRequestV2 as a CreatePipelineRequestV23
func (t CreatePipelineRequestV2) AsCreatePipelineRequestV23() (CreatePipelineRequestV23, error) {
	var body CreatePipelineRequestV23
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePipelineRequestV23 overwrites any union data inside the CreatePipelineRequestV2 as the provided CreatePipelineRequestV23
func (t *CreatePipelineRequestV2) FromCreatePipelineRequestV23(v CreatePipelineRequestV23) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePipelineRequestV23 performs a merge with any union data inside the CreatePipelineRequestV2, using the provided CreatePipelineRequestV23
func (t *CreatePipelineRequestV2) MergeCreatePipelineRequestV23(v CreatePipelineRequestV23) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreatePipelineRequestV24 returns the union data inside the CreatePipelineRequestV2 as a CreatePipelineRequestV24
func (t CreatePipelineRequestV2) AsCreatePipelineRequestV24() (CreatePipelineRequestV24, error) {
	var body CreatePipelineRequestV24
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreatePipelineRequestV24 overwrites any union data inside the CreatePipelineRequestV2 as the provided CreatePipelineRequestV24
func (t *CreatePipelineRequestV2) FromCreatePipelineRequestV24(v CreatePipelineRequestV24) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreatePipelineRequestV24 performs a merge with any union data inside the CreatePipelineRequestV2, using the provided CreatePipelineRequestV24
func (t *CreatePipelineRequestV2) MergeCreatePipelineRequestV24(v CreatePipelineRequestV24) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreatePipelineRequestV2) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreatePipelineRequestV2) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDataDockKind0 returns the union data inside the DataDockKind as a DataDockKind0
func (t DataDockKind) AsDataDockKind0() (DataDockKind0, error) {
	var body DataDockKind0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKind0 overwrites any union data inside the DataDockKind as the provided DataDockKind0
func (t *DataDockKind) FromDataDockKind0(v DataDockKind0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKind0 performs a merge with any union data inside the DataDockKind, using the provided DataDockKind0
func (t *DataDockKind) MergeDataDockKind0(v DataDockKind0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKind1 returns the union data inside the DataDockKind as a DataDockKind1
func (t DataDockKind) AsDataDockKind1() (DataDockKind1, error) {
	var body DataDockKind1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKind1 overwrites any union data inside the DataDockKind as the provided DataDockKind1
func (t *DataDockKind) FromDataDockKind1(v DataDockKind1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKind1 performs a merge with any union data inside the DataDockKind, using the provided DataDockKind1
func (t *DataDockKind) MergeDataDockKind1(v DataDockKind1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKind2 returns the union data inside the DataDockKind as a DataDockKind2
func (t DataDockKind) AsDataDockKind2() (DataDockKind2, error) {
	var body DataDockKind2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKind2 overwrites any union data inside the DataDockKind as the provided DataDockKind2
func (t *DataDockKind) FromDataDockKind2(v DataDockKind2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKind2 performs a merge with any union data inside the DataDockKind, using the provided DataDockKind2
func (t *DataDockKind) MergeDataDockKind2(v DataDockKind2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKind3 returns the union data inside the DataDockKind as a DataDockKind3
func (t DataDockKind) AsDataDockKind3() (DataDockKind3, error) {
	var body DataDockKind3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKind3 overwrites any union data inside the DataDockKind as the provided DataDockKind3
func (t *DataDockKind) FromDataDockKind3(v DataDockKind3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKind3 performs a merge with any union data inside the DataDockKind, using the provided DataDockKind3
func (t *DataDockKind) MergeDataDockKind3(v DataDockKind3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKind4 returns the union data inside the DataDockKind as a DataDockKind4
func (t DataDockKind) AsDataDockKind4() (DataDockKind4, error) {
	var body DataDockKind4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKind4 overwrites any union data inside the DataDockKind as the provided DataDockKind4
func (t *DataDockKind) FromDataDockKind4(v DataDockKind4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKind4 performs a merge with any union data inside the DataDockKind, using the provided DataDockKind4
func (t *DataDockKind) MergeDataDockKind4(v DataDockKind4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DataDockKind) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DataDockKind) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDataDockKindRequest0 returns the union data inside the DataDockKindRequest as a DataDockKindRequest0
func (t DataDockKindRequest) AsDataDockKindRequest0() (DataDockKindRequest0, error) {
	var body DataDockKindRequest0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindRequest0 overwrites any union data inside the DataDockKindRequest as the provided DataDockKindRequest0
func (t *DataDockKindRequest) FromDataDockKindRequest0(v DataDockKindRequest0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindRequest0 performs a merge with any union data inside the DataDockKindRequest, using the provided DataDockKindRequest0
func (t *DataDockKindRequest) MergeDataDockKindRequest0(v DataDockKindRequest0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKindRequest1 returns the union data inside the DataDockKindRequest as a DataDockKindRequest1
func (t DataDockKindRequest) AsDataDockKindRequest1() (DataDockKindRequest1, error) {
	var body DataDockKindRequest1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindRequest1 overwrites any union data inside the DataDockKindRequest as the provided DataDockKindRequest1
func (t *DataDockKindRequest) FromDataDockKindRequest1(v DataDockKindRequest1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindRequest1 performs a merge with any union data inside the DataDockKindRequest, using the provided DataDockKindRequest1
func (t *DataDockKindRequest) MergeDataDockKindRequest1(v DataDockKindRequest1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKindRequest2 returns the union data inside the DataDockKindRequest as a DataDockKindRequest2
func (t DataDockKindRequest) AsDataDockKindRequest2() (DataDockKindRequest2, error) {
	var body DataDockKindRequest2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindRequest2 overwrites any union data inside the DataDockKindRequest as the provided DataDockKindRequest2
func (t *DataDockKindRequest) FromDataDockKindRequest2(v DataDockKindRequest2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindRequest2 performs a merge with any union data inside the DataDockKindRequest, using the provided DataDockKindRequest2
func (t *DataDockKindRequest) MergeDataDockKindRequest2(v DataDockKindRequest2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKindRequest3 returns the union data inside the DataDockKindRequest as a DataDockKindRequest3
func (t DataDockKindRequest) AsDataDockKindRequest3() (DataDockKindRequest3, error) {
	var body DataDockKindRequest3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindRequest3 overwrites any union data inside the DataDockKindRequest as the provided DataDockKindRequest3
func (t *DataDockKindRequest) FromDataDockKindRequest3(v DataDockKindRequest3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindRequest3 performs a merge with any union data inside the DataDockKindRequest, using the provided DataDockKindRequest3
func (t *DataDockKindRequest) MergeDataDockKindRequest3(v DataDockKindRequest3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKindRequest4 returns the union data inside the DataDockKindRequest as a DataDockKindRequest4
func (t DataDockKindRequest) AsDataDockKindRequest4() (DataDockKindRequest4, error) {
	var body DataDockKindRequest4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindRequest4 overwrites any union data inside the DataDockKindRequest as the provided DataDockKindRequest4
func (t *DataDockKindRequest) FromDataDockKindRequest4(v DataDockKindRequest4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindRequest4 performs a merge with any union data inside the DataDockKindRequest, using the provided DataDockKindRequest4
func (t *DataDockKindRequest) MergeDataDockKindRequest4(v DataDockKindRequest4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DataDockKindRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DataDockKindRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDataDockKindResponse0 returns the union data inside the DataDockKindResponse as a DataDockKindResponse0
func (t DataDockKindResponse) AsDataDockKindResponse0() (DataDockKindResponse0, error) {
	var body DataDockKindResponse0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindResponse0 overwrites any union data inside the DataDockKindResponse as the provided DataDockKindResponse0
func (t *DataDockKindResponse) FromDataDockKindResponse0(v DataDockKindResponse0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindResponse0 performs a merge with any union data inside the DataDockKindResponse, using the provided DataDockKindResponse0
func (t *DataDockKindResponse) MergeDataDockKindResponse0(v DataDockKindResponse0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKindResponse1 returns the union data inside the DataDockKindResponse as a DataDockKindResponse1
func (t DataDockKindResponse) AsDataDockKindResponse1() (DataDockKindResponse1, error) {
	var body DataDockKindResponse1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindResponse1 overwrites any union data inside the DataDockKindResponse as the provided DataDockKindResponse1
func (t *DataDockKindResponse) FromDataDockKindResponse1(v DataDockKindResponse1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindResponse1 performs a merge with any union data inside the DataDockKindResponse, using the provided DataDockKindResponse1
func (t *DataDockKindResponse) MergeDataDockKindResponse1(v DataDockKindResponse1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKindResponse2 returns the union data inside the DataDockKindResponse as a DataDockKindResponse2
func (t DataDockKindResponse) AsDataDockKindResponse2() (DataDockKindResponse2, error) {
	var body DataDockKindResponse2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindResponse2 overwrites any union data inside the DataDockKindResponse as the provided DataDockKindResponse2
func (t *DataDockKindResponse) FromDataDockKindResponse2(v DataDockKindResponse2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindResponse2 performs a merge with any union data inside the DataDockKindResponse, using the provided DataDockKindResponse2
func (t *DataDockKindResponse) MergeDataDockKindResponse2(v DataDockKindResponse2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKindResponse3 returns the union data inside the DataDockKindResponse as a DataDockKindResponse3
func (t DataDockKindResponse) AsDataDockKindResponse3() (DataDockKindResponse3, error) {
	var body DataDockKindResponse3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindResponse3 overwrites any union data inside the DataDockKindResponse as the provided DataDockKindResponse3
func (t *DataDockKindResponse) FromDataDockKindResponse3(v DataDockKindResponse3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindResponse3 performs a merge with any union data inside the DataDockKindResponse, using the provided DataDockKindResponse3
func (t *DataDockKindResponse) MergeDataDockKindResponse3(v DataDockKindResponse3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDataDockKindResponse4 returns the union data inside the DataDockKindResponse as a DataDockKindResponse4
func (t DataDockKindResponse) AsDataDockKindResponse4() (DataDockKindResponse4, error) {
	var body DataDockKindResponse4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDataDockKindResponse4 overwrites any union data inside the DataDockKindResponse as the provided DataDockKindResponse4
func (t *DataDockKindResponse) FromDataDockKindResponse4(v DataDockKindResponse4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDataDockKindResponse4 performs a merge with any union data inside the DataDockKindResponse, using the provided DataDockKindResponse4
func (t *DataDockKindResponse) MergeDataDockKindResponse4(v DataDockKindResponse4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DataDockKindResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DataDockKindResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDedupingStrategy0 returns the union data inside the DedupingStrategy as a DedupingStrategy0
func (t DedupingStrategy) AsDedupingStrategy0() (DedupingStrategy0, error) {
	var body DedupingStrategy0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDedupingStrategy0 overwrites any union data inside the DedupingStrategy as the provided DedupingStrategy0
func (t *DedupingStrategy) FromDedupingStrategy0(v DedupingStrategy0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDedupingStrategy0 performs a merge with any union data inside the DedupingStrategy, using the provided DedupingStrategy0
func (t *DedupingStrategy) MergeDedupingStrategy0(v DedupingStrategy0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DedupingStrategy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DedupingStrategy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPipelineOutputParameters0 returns the union data inside the PipelineOutputParameters as a PipelineOutputParameters0
func (t PipelineOutputParameters) AsPipelineOutputParameters0() (PipelineOutputParameters0, error) {
	var body PipelineOutputParameters0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPipelineOutputParameters0 overwrites any union data inside the PipelineOutputParameters as the provided PipelineOutputParameters0
func (t *PipelineOutputParameters) FromPipelineOutputParameters0(v PipelineOutputParameters0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePipelineOutputParameters0 performs a merge with any union data inside the PipelineOutputParameters, using the provided PipelineOutputParameters0
func (t *PipelineOutputParameters) MergePipelineOutputParameters0(v PipelineOutputParameters0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPipelineOutputParameters1 returns the union data inside the PipelineOutputParameters as a PipelineOutputParameters1
func (t PipelineOutputParameters) AsPipelineOutputParameters1() (PipelineOutputParameters1, error) {
	var body PipelineOutputParameters1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPipelineOutputParameters1 overwrites any union data inside the PipelineOutputParameters as the provided PipelineOutputParameters1
func (t *PipelineOutputParameters) FromPipelineOutputParameters1(v PipelineOutputParameters1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePipelineOutputParameters1 performs a merge with any union data inside the PipelineOutputParameters, using the provided PipelineOutputParameters1
func (t *PipelineOutputParameters) MergePipelineOutputParameters1(v PipelineOutputParameters1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPipelineOutputParameters2 returns the union data inside the PipelineOutputParameters as a PipelineOutputParameters2
func (t PipelineOutputParameters) AsPipelineOutputParameters2() (PipelineOutputParameters2, error) {
	var body PipelineOutputParameters2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPipelineOutputParameters2 overwrites any union data inside the PipelineOutputParameters as the provided PipelineOutputParameters2
func (t *PipelineOutputParameters) FromPipelineOutputParameters2(v PipelineOutputParameters2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePipelineOutputParameters2 performs a merge with any union data inside the PipelineOutputParameters, using the provided PipelineOutputParameters2
func (t *PipelineOutputParameters) MergePipelineOutputParameters2(v PipelineOutputParameters2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPipelineOutputParameters3 returns the union data inside the PipelineOutputParameters as a PipelineOutputParameters3
func (t PipelineOutputParameters) AsPipelineOutputParameters3() (PipelineOutputParameters3, error) {
	var body PipelineOutputParameters3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPipelineOutputParameters3 overwrites any union data inside the PipelineOutputParameters as the provided PipelineOutputParameters3
func (t *PipelineOutputParameters) FromPipelineOutputParameters3(v PipelineOutputParameters3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePipelineOutputParameters3 performs a merge with any union data inside the PipelineOutputParameters, using the provided PipelineOutputParameters3
func (t *PipelineOutputParameters) MergePipelineOutputParameters3(v PipelineOutputParameters3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PipelineOutputParameters) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PipelineOutputParameters) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrepareArchiveImportResponse0 returns the union data inside the PrepareArchiveImportResponse as a PrepareArchiveImportResponse0
func (t PrepareArchiveImportResponse) AsPrepareArchiveImportResponse0() (PrepareArchiveImportResponse0, error) {
	var body PrepareArchiveImportResponse0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrepareArchiveImportResponse0 overwrites any union data inside the PrepareArchiveImportResponse as the provided PrepareArchiveImportResponse0
func (t *PrepareArchiveImportResponse) FromPrepareArchiveImportResponse0(v PrepareArchiveImportResponse0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrepareArchiveImportResponse0 performs a merge with any union data inside the PrepareArchiveImportResponse, using the provided PrepareArchiveImportResponse0
func (t *PrepareArchiveImportResponse) MergePrepareArchiveImportResponse0(v PrepareArchiveImportResponse0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrepareArchiveImportResponse1 returns the union data inside the PrepareArchiveImportResponse as a PrepareArchiveImportResponse1
func (t PrepareArchiveImportResponse) AsPrepareArchiveImportResponse1() (PrepareArchiveImportResponse1, error) {
	var body PrepareArchiveImportResponse1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrepareArchiveImportResponse1 overwrites any union data inside the PrepareArchiveImportResponse as the provided PrepareArchiveImportResponse1
func (t *PrepareArchiveImportResponse) FromPrepareArchiveImportResponse1(v PrepareArchiveImportResponse1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrepareArchiveImportResponse1 performs a merge with any union data inside the PrepareArchiveImportResponse, using the provided PrepareArchiveImportResponse1
func (t *PrepareArchiveImportResponse) MergePrepareArchiveImportResponse1(v PrepareArchiveImportResponse1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PrepareArchiveImportResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrepareArchiveImportResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// HandleGetConsoleConfig request
	HandleGetConsoleConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContextProviderHandler request
	DeleteContextProviderHandler(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContextProviderHandler request
	GetContextProviderHandler(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateContextProviderHandlerWithBody request with any body
	UpdateContextProviderHandlerWithBody(ctx context.Context, providerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateContextProviderHandler(ctx context.Context, providerId openapi_types.UUID, body UpdateContextProviderHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncContextProviderHandler request
	SyncContextProviderHandler(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContextualRestrictionHandler request
	DeleteContextualRestrictionHandler(ctx context.Context, restrictionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContextualRestrictionHandler request
	GetContextualRestrictionHandler(ctx context.Context, restrictionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateContextualRestrictionHandlerWithBody request with any body
	UpdateContextualRestrictionHandlerWithBody(ctx context.Context, restrictionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateContextualRestrictionHandler(ctx context.Context, restrictionId openapi_types.UUID, body UpdateContextualRestrictionHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBucketDataContainerWithBody request with any body
	CreateBucketDataContainerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBucketDataContainer(ctx context.Context, body CreateBucketDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBucketFile request
	DeleteBucketFile(ctx context.Context, dataContainerId openapi_types.UUID, params *DeleteBucketFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBucketFiles request
	ListBucketFiles(ctx context.Context, dataContainerId openapi_types.UUID, params *ListBucketFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadBucketFile request
	UploadBucketFile(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadBucketFile request
	DownloadBucketFile(ctx context.Context, dataContainerId openapi_types.UUID, params *DownloadBucketFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBucketFolderWithBody request with any body
	CreateBucketFolderWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBucketFolder(ctx context.Context, dataContainerId openapi_types.UUID, body CreateBucketFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBucketStats request
	GetBucketStats(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFakerFieldTypes request
	GetFakerFieldTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFakerSchemas request
	GetFakerSchemas(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFakerSchemaWithBody request with any body
	CreateFakerSchemaWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFakerSchema(ctx context.Context, dataContainerId openapi_types.UUID, body CreateFakerSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFakerSchema request
	DeleteFakerSchema(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFakerTableWithBody request with any body
	CreateFakerTableWithBody(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFakerTable(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFakerTableStructuredWithBody request with any body
	CreateFakerTableStructuredWithBody(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFakerTableStructured(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableStructuredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFakerTables request
	GetFakerTables(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFakerTable request
	DeleteFakerTable(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFakerTable request
	GetFakerTable(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFakerTableWithBody request with any body
	UpdateFakerTableWithBody(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFakerTable(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, body UpdateFakerTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIcebergDataContainerWithBody request with any body
	CreateIcebergDataContainerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIcebergDataContainer(ctx context.Context, body CreateIcebergDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIcebergDataContainer request
	GetIcebergDataContainer(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemas request
	GetSchemas(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSchemaWithBody request with any body
	CreateSchemaWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSchema(ctx context.Context, dataContainerId openapi_types.UUID, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTables request
	GetTables(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, dataContainerId openapi_types.UUID, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloneTableWithBody request with any body
	CloneTableWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CloneTable(ctx context.Context, dataContainerId openapi_types.UUID, body CloneTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataContainer request
	DeleteDataContainer(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataContainer request
	GetDataContainer(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDataDockCrdWithBody request with any body
	CreateDataDockCrdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDataDockCrd(ctx context.Context, body CreateDataDockCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataDockCrd request
	DeleteDataDockCrd(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDataContainers request
	ListDataContainers(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveExportDataContainerWithBody request with any body
	ArchiveExportDataContainerWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveExportDataContainer(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveExportDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveImportDataContainerWithBody request with any body
	ArchiveImportDataContainerWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveImportDataContainer(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveImportDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortMultipartUploadWithBody request with any body
	AbortMultipartUploadWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AbortMultipartUpload(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body AbortMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteMultipartUploadWithBody request with any body
	CompleteMultipartUploadWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteMultipartUpload(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body CompleteMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareArchiveImportWithBody request with any body
	PrepareArchiveImportWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareArchiveImport(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body PrepareArchiveImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListArchiveOperations request
	ListArchiveOperations(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, params *ListArchiveOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArchiveOperation request
	GetArchiveOperation(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadArchiveOperation request
	DownloadArchiveOperation(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, params *DownloadArchiveOperationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataDockSecuritySettingsHandler request
	GetDataDockSecuritySettingsHandler(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDataDockSecuritySettingsHandlerWithBody request with any body
	UpdateDataDockSecuritySettingsHandlerWithBody(ctx context.Context, dataDockId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDataDockSecuritySettingsHandler(ctx context.Context, dataDockId openapi_types.UUID, body UpdateDataDockSecuritySettingsHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHarborDataDock request
	ListHarborDataDock(ctx context.Context, harborId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrganizations request
	ListOrganizations(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrganizationCrdWithBody request with any body
	CreateOrganizationCrdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrganizationCrd(ctx context.Context, body CreateOrganizationCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckOrganizationNameAvailability request
	CheckOrganizationNameAvailability(ctx context.Context, params *CheckOrganizationNameAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationById request
	GetOrganizationById(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApiKeys request
	ListApiKeys(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyWithBody request with any body
	CreateApiKeyWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKey(ctx context.Context, organizationId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeApiKey request
	RevokeApiKey(ctx context.Context, organizationId openapi_types.UUID, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationCrd request
	DeleteOrganizationCrd(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListHarbors request
	ListHarbors(ctx context.Context, organizationId openapi_types.UUID, params *ListHarborsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHarborCrdWithBody request with any body
	CreateHarborCrdWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHarborCrd(ctx context.Context, organizationId openapi_types.UUID, body CreateHarborCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHarborCrd request
	DeleteHarborCrd(ctx context.Context, organizationId openapi_types.UUID, harborSlug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckHarborNameAvailable request
	CheckHarborNameAvailable(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModelServings request
	ListModelServings(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModelServingWithBody request with any body
	CreateModelServingWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateModelServing(ctx context.Context, organizationId openapi_types.UUID, body CreateModelServingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModelServing request
	DeleteModelServing(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModelServing request
	GetModelServing(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchModelServingWithBody request with any body
	PatchModelServingWithBody(ctx context.Context, organizationId openapi_types.UUID, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchModelServing(ctx context.Context, organizationId openapi_types.UUID, name string, body PatchModelServingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPipelines request
	ListPipelines(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePipeline request
	DeletePipeline(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPipelineRuns request
	ListPipelineRuns(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineRun request
	GetPipelineRun(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, runId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerPipeline request
	TriggerPipeline(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountCrdWithBody request with any body
	CreateServiceAccountCrdWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountCrd(ctx context.Context, organizationId openapi_types.UUID, body CreateServiceAccountCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountCrd request
	DeleteServiceAccountCrd(ctx context.Context, organizationId openapi_types.UUID, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceAccountCrdWithBody request with any body
	UpdateServiceAccountCrdWithBody(ctx context.Context, organizationId openapi_types.UUID, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceAccountCrd(ctx context.Context, organizationId openapi_types.UUID, clientId string, body UpdateServiceAccountCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrgUserAttributesHandler request
	ListOrgUserAttributesHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrgUsers request
	ListOrgUsers(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserToOrganizationWithBody request with any body
	AddUserToOrganizationWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserToOrganization(ctx context.Context, organizationId openapi_types.UUID, body AddUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserFromOrganization request
	RemoveUserFromOrganization(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserAttributesHandler request
	ListUserAttributesHandler(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserAttributeHandlerWithBody request with any body
	AddUserAttributeHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserAttributeHandler(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, body AddUserAttributeHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetUserAttributesHandlerWithBody request with any body
	SetUserAttributesHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetUserAttributesHandler(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, body SetUserAttributesHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveUserAttributeHandler request
	RemoveUserAttributeHandler(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, attribute string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContextProvidersHandler request
	ListContextProvidersHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateContextProviderHandlerWithBody request with any body
	CreateContextProviderHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateContextProviderHandler(ctx context.Context, organizationId openapi_types.UUID, body CreateContextProviderHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContextualRestrictionsHandler request
	ListContextualRestrictionsHandler(ctx context.Context, organizationId openapi_types.UUID, params *ListContextualRestrictionsHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateContextualRestrictionHandlerWithBody request with any body
	CreateContextualRestrictionHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateContextualRestrictionHandler(ctx context.Context, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, body CreateContextualRestrictionHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDataDocks request
	ListDataDocks(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshOrgDataDocks request
	RefreshOrgDataDocks(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEffectiveSecuritySettingsHandler request
	GetEffectiveSecuritySettingsHandler(ctx context.Context, organizationId openapi_types.UUID, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrgSecuritySettingsHandler request
	GetOrgSecuritySettingsHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrgSecuritySettingsHandlerWithBody request with any body
	UpdateOrgSecuritySettingsHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrgSecuritySettingsHandler(ctx context.Context, organizationId openapi_types.UUID, body UpdateOrgSecuritySettingsHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServiceAccountsHandler request
	ListServiceAccountsHandler(ctx context.Context, organizationId openapi_types.UUID, params *ListServiceAccountsHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadServiceAccountHandler request
	DownloadServiceAccountHandler(ctx context.Context, organizationId openapi_types.UUID, serviceAccountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTableClassificationsHandler request
	ListTableClassificationsHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableClassificationHandlerWithBody request with any body
	CreateTableClassificationHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTableClassificationHandler(ctx context.Context, organizationId openapi_types.UUID, body CreateTableClassificationHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AiClassifyHandlerWithBody request with any body
	AiClassifyHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AiClassifyHandler(ctx context.Context, organizationId openapi_types.UUID, body AiClassifyHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTableClassificationStatsHandler request
	GetTableClassificationStatsHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTableClassificationHandler request
	DeleteTableClassificationHandler(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTableClassificationHandlerWithBody request with any body
	UpdateTableClassificationHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTableClassificationHandler(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, body UpdateTableClassificationHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserContextHandler request
	GetUserContextHandler(ctx context.Context, organizationId openapi_types.UUID, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePipelineWithBody request with any body
	CreatePipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePipeline(ctx context.Context, body CreatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountRefsWithBody request with any body
	CountRefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CountRefs(ctx context.Context, body CountRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRefs request
	ListRefs(ctx context.Context, params *ListRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRefWithBody request with any body
	UpdateRefWithBody(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRef(ctx context.Context, key string, body UpdateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelQueryHandler request
	CancelQueryHandler(ctx context.Context, trinoQueryId string, params *CancelQueryHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteQueryHandlerWithBody request with any body
	ExecuteQueryHandlerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteQueryHandler(ctx context.Context, body ExecuteQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHistoryHandler request
	GetHistoryHandler(ctx context.Context, params *GetHistoryHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSavedQueriesHandler request
	ListSavedQueriesHandler(ctx context.Context, params *ListSavedQueriesHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSavedQueryHandlerWithBody request with any body
	CreateSavedQueryHandlerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSavedQueryHandler(ctx context.Context, body CreateSavedQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSavedQueryHandler request
	DeleteSavedQueryHandler(ctx context.Context, queryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSavedQueryHandler request
	GetSavedQueryHandler(ctx context.Context, queryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSavedQueryHandlerWithBody request with any body
	UpdateSavedQueryHandlerWithBody(ctx context.Context, queryId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSavedQueryHandler(ctx context.Context, queryId openapi_types.UUID, body UpdateSavedQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResultsHandler request
	GetResultsHandler(ctx context.Context, queryId openapi_types.UUID, params *GetResultsHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchemaHandler request
	GetSchemaHandler(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnifiedCatalog request
	GetUnifiedCatalog(ctx context.Context, params *GetUnifiedCatalogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePipelineV2WithBody request with any body
	CreatePipelineV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePipelineV2(ctx context.Context, body CreatePipelineV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) HandleGetConsoleConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHandleGetConsoleConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContextProviderHandler(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContextProviderHandlerRequest(c.Server, providerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContextProviderHandler(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContextProviderHandlerRequest(c.Server, providerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContextProviderHandlerWithBody(ctx context.Context, providerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContextProviderHandlerRequestWithBody(c.Server, providerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContextProviderHandler(ctx context.Context, providerId openapi_types.UUID, body UpdateContextProviderHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContextProviderHandlerRequest(c.Server, providerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncContextProviderHandler(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncContextProviderHandlerRequest(c.Server, providerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContextualRestrictionHandler(ctx context.Context, restrictionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContextualRestrictionHandlerRequest(c.Server, restrictionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContextualRestrictionHandler(ctx context.Context, restrictionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContextualRestrictionHandlerRequest(c.Server, restrictionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContextualRestrictionHandlerWithBody(ctx context.Context, restrictionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContextualRestrictionHandlerRequestWithBody(c.Server, restrictionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContextualRestrictionHandler(ctx context.Context, restrictionId openapi_types.UUID, body UpdateContextualRestrictionHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContextualRestrictionHandlerRequest(c.Server, restrictionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketDataContainerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketDataContainerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketDataContainer(ctx context.Context, body CreateBucketDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketDataContainerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBucketFile(ctx context.Context, dataContainerId openapi_types.UUID, params *DeleteBucketFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBucketFileRequest(c.Server, dataContainerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBucketFiles(ctx context.Context, dataContainerId openapi_types.UUID, params *ListBucketFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBucketFilesRequest(c.Server, dataContainerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadBucketFile(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadBucketFileRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadBucketFile(ctx context.Context, dataContainerId openapi_types.UUID, params *DownloadBucketFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadBucketFileRequest(c.Server, dataContainerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketFolderWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketFolderRequestWithBody(c.Server, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBucketFolder(ctx context.Context, dataContainerId openapi_types.UUID, body CreateBucketFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBucketFolderRequest(c.Server, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBucketStats(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBucketStatsRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFakerFieldTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFakerFieldTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFakerSchemas(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFakerSchemasRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFakerSchemaWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFakerSchemaRequestWithBody(c.Server, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFakerSchema(ctx context.Context, dataContainerId openapi_types.UUID, body CreateFakerSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFakerSchemaRequest(c.Server, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFakerSchema(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFakerSchemaRequest(c.Server, dataContainerId, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFakerTableWithBody(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFakerTableRequestWithBody(c.Server, dataContainerId, schemaId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFakerTable(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFakerTableRequest(c.Server, dataContainerId, schemaId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFakerTableStructuredWithBody(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFakerTableStructuredRequestWithBody(c.Server, dataContainerId, schemaId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFakerTableStructured(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableStructuredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFakerTableStructuredRequest(c.Server, dataContainerId, schemaId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFakerTables(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFakerTablesRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFakerTable(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFakerTableRequest(c.Server, dataContainerId, tableId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFakerTable(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFakerTableRequest(c.Server, dataContainerId, tableId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFakerTableWithBody(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFakerTableRequestWithBody(c.Server, dataContainerId, tableId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFakerTable(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, body UpdateFakerTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFakerTableRequest(c.Server, dataContainerId, tableId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIcebergDataContainerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIcebergDataContainerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIcebergDataContainer(ctx context.Context, body CreateIcebergDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIcebergDataContainerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIcebergDataContainer(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIcebergDataContainerRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemas(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemasRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchemaWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchemaRequestWithBody(c.Server, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchema(ctx context.Context, dataContainerId openapi_types.UUID, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchemaRequest(c.Server, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTables(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTablesRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, dataContainerId openapi_types.UUID, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneTableWithBody(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneTableRequestWithBody(c.Server, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneTable(ctx context.Context, dataContainerId openapi_types.UUID, body CloneTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneTableRequest(c.Server, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataContainer(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataContainerRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataContainer(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataContainerRequest(c.Server, dataContainerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataDockCrdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataDockCrdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataDockCrd(ctx context.Context, body CreateDataDockCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataDockCrdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataDockCrd(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataDockCrdRequest(c.Server, dataDockId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDataContainers(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDataContainersRequest(c.Server, dataDockId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveExportDataContainerWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveExportDataContainerRequestWithBody(c.Server, dataDockId, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveExportDataContainer(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveExportDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveExportDataContainerRequest(c.Server, dataDockId, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveImportDataContainerWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveImportDataContainerRequestWithBody(c.Server, dataDockId, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveImportDataContainer(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveImportDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveImportDataContainerRequest(c.Server, dataDockId, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortMultipartUploadWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortMultipartUploadRequestWithBody(c.Server, dataDockId, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortMultipartUpload(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body AbortMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortMultipartUploadRequest(c.Server, dataDockId, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteMultipartUploadWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteMultipartUploadRequestWithBody(c.Server, dataDockId, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteMultipartUpload(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body CompleteMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteMultipartUploadRequest(c.Server, dataDockId, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareArchiveImportWithBody(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareArchiveImportRequestWithBody(c.Server, dataDockId, dataContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareArchiveImport(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body PrepareArchiveImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareArchiveImportRequest(c.Server, dataDockId, dataContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArchiveOperations(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, params *ListArchiveOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArchiveOperationsRequest(c.Server, dataDockId, dataContainerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArchiveOperation(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArchiveOperationRequest(c.Server, dataDockId, dataContainerId, operationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadArchiveOperation(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, params *DownloadArchiveOperationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadArchiveOperationRequest(c.Server, dataDockId, dataContainerId, operationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataDockSecuritySettingsHandler(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataDockSecuritySettingsHandlerRequest(c.Server, dataDockId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataDockSecuritySettingsHandlerWithBody(ctx context.Context, dataDockId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataDockSecuritySettingsHandlerRequestWithBody(c.Server, dataDockId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataDockSecuritySettingsHandler(ctx context.Context, dataDockId openapi_types.UUID, body UpdateDataDockSecuritySettingsHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataDockSecuritySettingsHandlerRequest(c.Server, dataDockId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHarborDataDock(ctx context.Context, harborId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHarborDataDockRequest(c.Server, harborId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrganizations(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationCrdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationCrdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrganizationCrd(ctx context.Context, body CreateOrganizationCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrganizationCrdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckOrganizationNameAvailability(ctx context.Context, params *CheckOrganizationNameAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckOrganizationNameAvailabilityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationById(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationByIdRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApiKeys(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKey(ctx context.Context, organizationId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeApiKey(ctx context.Context, organizationId openapi_types.UUID, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeApiKeyRequest(c.Server, organizationId, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationCrd(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationCrdRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListHarbors(ctx context.Context, organizationId openapi_types.UUID, params *ListHarborsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListHarborsRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHarborCrdWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHarborCrdRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHarborCrd(ctx context.Context, organizationId openapi_types.UUID, body CreateHarborCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHarborCrdRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHarborCrd(ctx context.Context, organizationId openapi_types.UUID, harborSlug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHarborCrdRequest(c.Server, organizationId, harborSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckHarborNameAvailable(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckHarborNameAvailableRequest(c.Server, organizationId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModelServings(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelServingsRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelServingWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelServingRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelServing(ctx context.Context, organizationId openapi_types.UUID, body CreateModelServingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelServingRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModelServing(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModelServingRequest(c.Server, organizationId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModelServing(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModelServingRequest(c.Server, organizationId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchModelServingWithBody(ctx context.Context, organizationId openapi_types.UUID, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchModelServingRequestWithBody(c.Server, organizationId, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchModelServing(ctx context.Context, organizationId openapi_types.UUID, name string, body PatchModelServingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchModelServingRequest(c.Server, organizationId, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPipelines(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPipelinesRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePipeline(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePipelineRequest(c.Server, organizationId, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPipelineRuns(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPipelineRunsRequest(c.Server, organizationId, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineRun(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, runId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineRunRequest(c.Server, organizationId, pipelineId, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPipeline(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerPipelineRequest(c.Server, organizationId, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountCrdWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountCrdRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountCrd(ctx context.Context, organizationId openapi_types.UUID, body CreateServiceAccountCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountCrdRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountCrd(ctx context.Context, organizationId openapi_types.UUID, clientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountCrdRequest(c.Server, organizationId, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountCrdWithBody(ctx context.Context, organizationId openapi_types.UUID, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountCrdRequestWithBody(c.Server, organizationId, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountCrd(ctx context.Context, organizationId openapi_types.UUID, clientId string, body UpdateServiceAccountCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountCrdRequest(c.Server, organizationId, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrgUserAttributesHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrgUserAttributesHandlerRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrgUsers(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrgUsersRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToOrganizationWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToOrganizationRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserToOrganization(ctx context.Context, organizationId openapi_types.UUID, body AddUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserToOrganizationRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserFromOrganization(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserFromOrganizationRequest(c.Server, organizationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserAttributesHandler(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserAttributesHandlerRequest(c.Server, organizationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserAttributeHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserAttributeHandlerRequestWithBody(c.Server, organizationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserAttributeHandler(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, body AddUserAttributeHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserAttributeHandlerRequest(c.Server, organizationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetUserAttributesHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetUserAttributesHandlerRequestWithBody(c.Server, organizationId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetUserAttributesHandler(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, body SetUserAttributesHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetUserAttributesHandlerRequest(c.Server, organizationId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveUserAttributeHandler(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, attribute string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveUserAttributeHandlerRequest(c.Server, organizationId, userId, attribute)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContextProvidersHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContextProvidersHandlerRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContextProviderHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContextProviderHandlerRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContextProviderHandler(ctx context.Context, organizationId openapi_types.UUID, body CreateContextProviderHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContextProviderHandlerRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContextualRestrictionsHandler(ctx context.Context, organizationId openapi_types.UUID, params *ListContextualRestrictionsHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContextualRestrictionsHandlerRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContextualRestrictionHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContextualRestrictionHandlerRequestWithBody(c.Server, organizationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContextualRestrictionHandler(ctx context.Context, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, body CreateContextualRestrictionHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContextualRestrictionHandlerRequest(c.Server, organizationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDataDocks(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDataDocksRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshOrgDataDocks(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshOrgDataDocksRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEffectiveSecuritySettingsHandler(ctx context.Context, organizationId openapi_types.UUID, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEffectiveSecuritySettingsHandlerRequest(c.Server, organizationId, dataDockId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrgSecuritySettingsHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrgSecuritySettingsHandlerRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrgSecuritySettingsHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgSecuritySettingsHandlerRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrgSecuritySettingsHandler(ctx context.Context, organizationId openapi_types.UUID, body UpdateOrgSecuritySettingsHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrgSecuritySettingsHandlerRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServiceAccountsHandler(ctx context.Context, organizationId openapi_types.UUID, params *ListServiceAccountsHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServiceAccountsHandlerRequest(c.Server, organizationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadServiceAccountHandler(ctx context.Context, organizationId openapi_types.UUID, serviceAccountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadServiceAccountHandlerRequest(c.Server, organizationId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTableClassificationsHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTableClassificationsHandlerRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableClassificationHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableClassificationHandlerRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableClassificationHandler(ctx context.Context, organizationId openapi_types.UUID, body CreateTableClassificationHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableClassificationHandlerRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AiClassifyHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAiClassifyHandlerRequestWithBody(c.Server, organizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AiClassifyHandler(ctx context.Context, organizationId openapi_types.UUID, body AiClassifyHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAiClassifyHandlerRequest(c.Server, organizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTableClassificationStatsHandler(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableClassificationStatsHandlerRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTableClassificationHandler(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTableClassificationHandlerRequest(c.Server, organizationId, classificationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTableClassificationHandlerWithBody(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableClassificationHandlerRequestWithBody(c.Server, organizationId, classificationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTableClassificationHandler(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, body UpdateTableClassificationHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableClassificationHandlerRequest(c.Server, organizationId, classificationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserContextHandler(ctx context.Context, organizationId openapi_types.UUID, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserContextHandlerRequest(c.Server, organizationId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipeline(ctx context.Context, body CreatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountRefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountRefsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountRefs(ctx context.Context, body CountRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountRefsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRefs(ctx context.Context, params *ListRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRefsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRefWithBody(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRefRequestWithBody(c.Server, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRef(ctx context.Context, key string, body UpdateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRefRequest(c.Server, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelQueryHandler(ctx context.Context, trinoQueryId string, params *CancelQueryHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelQueryHandlerRequest(c.Server, trinoQueryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteQueryHandlerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteQueryHandlerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteQueryHandler(ctx context.Context, body ExecuteQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteQueryHandlerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHistoryHandler(ctx context.Context, params *GetHistoryHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHistoryHandlerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSavedQueriesHandler(ctx context.Context, params *ListSavedQueriesHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSavedQueriesHandlerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSavedQueryHandlerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSavedQueryHandlerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSavedQueryHandler(ctx context.Context, body CreateSavedQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSavedQueryHandlerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSavedQueryHandler(ctx context.Context, queryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSavedQueryHandlerRequest(c.Server, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSavedQueryHandler(ctx context.Context, queryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSavedQueryHandlerRequest(c.Server, queryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSavedQueryHandlerWithBody(ctx context.Context, queryId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSavedQueryHandlerRequestWithBody(c.Server, queryId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSavedQueryHandler(ctx context.Context, queryId openapi_types.UUID, body UpdateSavedQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSavedQueryHandlerRequest(c.Server, queryId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResultsHandler(ctx context.Context, queryId openapi_types.UUID, params *GetResultsHandlerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResultsHandlerRequest(c.Server, queryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchemaHandler(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaHandlerRequest(c.Server, dataDockId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnifiedCatalog(ctx context.Context, params *GetUnifiedCatalogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnifiedCatalogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipelineV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipelineV2(ctx context.Context, body CreatePipelineV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewHandleGetConsoleConfigRequest generates requests for HandleGetConsoleConfig
func NewHandleGetConsoleConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteContextProviderHandlerRequest generates requests for DeleteContextProviderHandler
func NewDeleteContextProviderHandlerRequest(server string, providerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/context-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContextProviderHandlerRequest generates requests for GetContextProviderHandler
func NewGetContextProviderHandlerRequest(server string, providerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/context-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateContextProviderHandlerRequest calls the generic UpdateContextProviderHandler builder with application/json body
func NewUpdateContextProviderHandlerRequest(server string, providerId openapi_types.UUID, body UpdateContextProviderHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateContextProviderHandlerRequestWithBody(server, providerId, "application/json", bodyReader)
}

// NewUpdateContextProviderHandlerRequestWithBody generates requests for UpdateContextProviderHandler with any type of body
func NewUpdateContextProviderHandlerRequestWithBody(server string, providerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/context-providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSyncContextProviderHandlerRequest generates requests for SyncContextProviderHandler
func NewSyncContextProviderHandlerRequest(server string, providerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider_id", runtime.ParamLocationPath, providerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/context-providers/%s/sync", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteContextualRestrictionHandlerRequest generates requests for DeleteContextualRestrictionHandler
func NewDeleteContextualRestrictionHandlerRequest(server string, restrictionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "restriction_id", runtime.ParamLocationPath, restrictionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/contextual-restrictions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContextualRestrictionHandlerRequest generates requests for GetContextualRestrictionHandler
func NewGetContextualRestrictionHandlerRequest(server string, restrictionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "restriction_id", runtime.ParamLocationPath, restrictionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/contextual-restrictions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateContextualRestrictionHandlerRequest calls the generic UpdateContextualRestrictionHandler builder with application/json body
func NewUpdateContextualRestrictionHandlerRequest(server string, restrictionId openapi_types.UUID, body UpdateContextualRestrictionHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateContextualRestrictionHandlerRequestWithBody(server, restrictionId, "application/json", bodyReader)
}

// NewUpdateContextualRestrictionHandlerRequestWithBody generates requests for UpdateContextualRestrictionHandler with any type of body
func NewUpdateContextualRestrictionHandlerRequestWithBody(server string, restrictionId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "restriction_id", runtime.ParamLocationPath, restrictionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/contextual-restrictions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBucketDataContainerRequest calls the generic CreateBucketDataContainer builder with application/json body
func NewCreateBucketDataContainerRequest(server string, body CreateBucketDataContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBucketDataContainerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBucketDataContainerRequestWithBody generates requests for CreateBucketDataContainer with any type of body
func NewCreateBucketDataContainerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/bucket")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBucketFileRequest generates requests for DeleteBucketFile
func NewDeleteBucketFileRequest(server string, dataContainerId openapi_types.UUID, params *DeleteBucketFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/bucket/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBucketFilesRequest generates requests for ListBucketFiles
func NewListBucketFilesRequest(server string, dataContainerId openapi_types.UUID, params *ListBucketFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/bucket/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadBucketFileRequest generates requests for UploadBucketFile
func NewUploadBucketFileRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/bucket/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadBucketFileRequest generates requests for DownloadBucketFile
func NewDownloadBucketFileRequest(server string, dataContainerId openapi_types.UUID, params *DownloadBucketFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/bucket/%s/files/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBucketFolderRequest calls the generic CreateBucketFolder builder with application/json body
func NewCreateBucketFolderRequest(server string, dataContainerId openapi_types.UUID, body CreateBucketFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBucketFolderRequestWithBody(server, dataContainerId, "application/json", bodyReader)
}

// NewCreateBucketFolderRequestWithBody generates requests for CreateBucketFolder with any type of body
func NewCreateBucketFolderRequestWithBody(server string, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/bucket/%s/folders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBucketStatsRequest generates requests for GetBucketStats
func NewGetBucketStatsRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/bucket/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFakerFieldTypesRequest generates requests for GetFakerFieldTypes
func NewGetFakerFieldTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/field-types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFakerSchemasRequest generates requests for GetFakerSchemas
func NewGetFakerSchemasRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFakerSchemaRequest calls the generic CreateFakerSchema builder with application/json body
func NewCreateFakerSchemaRequest(server string, dataContainerId openapi_types.UUID, body CreateFakerSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFakerSchemaRequestWithBody(server, dataContainerId, "application/json", bodyReader)
}

// NewCreateFakerSchemaRequestWithBody generates requests for CreateFakerSchema with any type of body
func NewCreateFakerSchemaRequestWithBody(server string, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFakerSchemaRequest generates requests for DeleteFakerSchema
func NewDeleteFakerSchemaRequest(server string, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/schemas/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFakerTableRequest calls the generic CreateFakerTable builder with application/json body
func NewCreateFakerTableRequest(server string, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFakerTableRequestWithBody(server, dataContainerId, schemaId, "application/json", bodyReader)
}

// NewCreateFakerTableRequestWithBody generates requests for CreateFakerTable with any type of body
func NewCreateFakerTableRequestWithBody(server string, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/schemas/%s/tables", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFakerTableStructuredRequest calls the generic CreateFakerTableStructured builder with application/json body
func NewCreateFakerTableStructuredRequest(server string, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableStructuredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFakerTableStructuredRequestWithBody(server, dataContainerId, schemaId, "application/json", bodyReader)
}

// NewCreateFakerTableStructuredRequestWithBody generates requests for CreateFakerTableStructured with any type of body
func NewCreateFakerTableStructuredRequestWithBody(server string, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/schemas/%s/tables/structured", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFakerTablesRequest generates requests for GetFakerTables
func NewGetFakerTablesRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFakerTableRequest generates requests for DeleteFakerTable
func NewDeleteFakerTableRequest(server string, dataContainerId openapi_types.UUID, tableId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table_id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFakerTableRequest generates requests for GetFakerTable
func NewGetFakerTableRequest(server string, dataContainerId openapi_types.UUID, tableId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table_id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFakerTableRequest calls the generic UpdateFakerTable builder with application/json body
func NewUpdateFakerTableRequest(server string, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, body UpdateFakerTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFakerTableRequestWithBody(server, dataContainerId, tableId, "application/json", bodyReader)
}

// NewUpdateFakerTableRequestWithBody generates requests for UpdateFakerTable with any type of body
func NewUpdateFakerTableRequestWithBody(server string, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "table_id", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/faker/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateIcebergDataContainerRequest calls the generic CreateIcebergDataContainer builder with application/json body
func NewCreateIcebergDataContainerRequest(server string, body CreateIcebergDataContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIcebergDataContainerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIcebergDataContainerRequestWithBody generates requests for CreateIcebergDataContainer with any type of body
func NewCreateIcebergDataContainerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/iceberg")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIcebergDataContainerRequest generates requests for GetIcebergDataContainer
func NewGetIcebergDataContainerRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/iceberg/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemasRequest generates requests for GetSchemas
func NewGetSchemasRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/iceberg/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSchemaRequest calls the generic CreateSchema builder with application/json body
func NewCreateSchemaRequest(server string, dataContainerId openapi_types.UUID, body CreateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSchemaRequestWithBody(server, dataContainerId, "application/json", bodyReader)
}

// NewCreateSchemaRequestWithBody generates requests for CreateSchema with any type of body
func NewCreateSchemaRequestWithBody(server string, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/iceberg/%s/schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTablesRequest generates requests for GetTables
func NewGetTablesRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/iceberg/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, dataContainerId openapi_types.UUID, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, dataContainerId, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/iceberg/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCloneTableRequest calls the generic CloneTable builder with application/json body
func NewCloneTableRequest(server string, dataContainerId openapi_types.UUID, body CloneTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCloneTableRequestWithBody(server, dataContainerId, "application/json", bodyReader)
}

// NewCloneTableRequestWithBody generates requests for CloneTable with any type of body
func NewCloneTableRequestWithBody(server string, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/iceberg/%s/tables/clone", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDataContainerRequest generates requests for DeleteDataContainer
func NewDeleteDataContainerRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataContainerRequest generates requests for GetDataContainer
func NewGetDataContainerRequest(server string, dataContainerId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDataDockCrdRequest calls the generic CreateDataDockCrd builder with application/json body
func NewCreateDataDockCrdRequest(server string, body CreateDataDockCrdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDataDockCrdRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDataDockCrdRequestWithBody generates requests for CreateDataDockCrd with any type of body
func NewCreateDataDockCrdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/crd")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDataDockCrdRequest generates requests for DeleteDataDockCrd
func NewDeleteDataDockCrdRequest(server string, dataDockId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/crd", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDataContainersRequest generates requests for ListDataContainers
func NewListDataContainersRequest(server string, dataDockId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveExportDataContainerRequest calls the generic ArchiveExportDataContainer builder with application/json body
func NewArchiveExportDataContainerRequest(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveExportDataContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveExportDataContainerRequestWithBody(server, dataDockId, dataContainerId, "application/json", bodyReader)
}

// NewArchiveExportDataContainerRequestWithBody generates requests for ArchiveExportDataContainer with any type of body
func NewArchiveExportDataContainerRequestWithBody(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers/%s/archive-export", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveImportDataContainerRequest calls the generic ArchiveImportDataContainer builder with application/json body
func NewArchiveImportDataContainerRequest(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveImportDataContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveImportDataContainerRequestWithBody(server, dataDockId, dataContainerId, "application/json", bodyReader)
}

// NewArchiveImportDataContainerRequestWithBody generates requests for ArchiveImportDataContainer with any type of body
func NewArchiveImportDataContainerRequestWithBody(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers/%s/archive-import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAbortMultipartUploadRequest calls the generic AbortMultipartUpload builder with application/json body
func NewAbortMultipartUploadRequest(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body AbortMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAbortMultipartUploadRequestWithBody(server, dataDockId, dataContainerId, "application/json", bodyReader)
}

// NewAbortMultipartUploadRequestWithBody generates requests for AbortMultipartUpload with any type of body
func NewAbortMultipartUploadRequestWithBody(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers/%s/archive-import/abort-multipart", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompleteMultipartUploadRequest calls the generic CompleteMultipartUpload builder with application/json body
func NewCompleteMultipartUploadRequest(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body CompleteMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteMultipartUploadRequestWithBody(server, dataDockId, dataContainerId, "application/json", bodyReader)
}

// NewCompleteMultipartUploadRequestWithBody generates requests for CompleteMultipartUpload with any type of body
func NewCompleteMultipartUploadRequestWithBody(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers/%s/archive-import/complete-multipart", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrepareArchiveImportRequest calls the generic PrepareArchiveImport builder with application/json body
func NewPrepareArchiveImportRequest(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body PrepareArchiveImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareArchiveImportRequestWithBody(server, dataDockId, dataContainerId, "application/json", bodyReader)
}

// NewPrepareArchiveImportRequestWithBody generates requests for PrepareArchiveImport with any type of body
func NewPrepareArchiveImportRequestWithBody(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers/%s/archive-import/prepare", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListArchiveOperationsRequest generates requests for ListArchiveOperations
func NewListArchiveOperationsRequest(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, params *ListArchiveOperationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers/%s/archive-operations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArchiveOperationRequest generates requests for GetArchiveOperation
func NewGetArchiveOperationRequest(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "operation_id", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers/%s/archive-operations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadArchiveOperationRequest generates requests for DownloadArchiveOperation
func NewDownloadArchiveOperationRequest(server string, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, params *DownloadArchiveOperationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_container_id", runtime.ParamLocationPath, dataContainerId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "operation_id", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/data-containers/%s/archive-operations/%s/download", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExpiresIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expires_in", runtime.ParamLocationQuery, *params.ExpiresIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataDockSecuritySettingsHandlerRequest generates requests for GetDataDockSecuritySettingsHandler
func NewGetDataDockSecuritySettingsHandlerRequest(server string, dataDockId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/security/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDataDockSecuritySettingsHandlerRequest calls the generic UpdateDataDockSecuritySettingsHandler builder with application/json body
func NewUpdateDataDockSecuritySettingsHandlerRequest(server string, dataDockId openapi_types.UUID, body UpdateDataDockSecuritySettingsHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDataDockSecuritySettingsHandlerRequestWithBody(server, dataDockId, "application/json", bodyReader)
}

// NewUpdateDataDockSecuritySettingsHandlerRequestWithBody generates requests for UpdateDataDockSecuritySettingsHandler with any type of body
func NewUpdateDataDockSecuritySettingsHandlerRequestWithBody(server string, dataDockId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/data-docks/%s/security/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListHarborDataDockRequest generates requests for ListHarborDataDock
func NewListHarborDataDockRequest(server string, harborId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "harbor_id", runtime.ParamLocationPath, harborId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/harbors/%s/data-docks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOrganizationsRequest generates requests for ListOrganizations
func NewListOrganizationsRequest(server string, params *ListOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Slug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slug", runtime.ParamLocationQuery, *params.Slug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrganizationCrdRequest calls the generic CreateOrganizationCrd builder with application/json body
func NewCreateOrganizationCrdRequest(server string, body CreateOrganizationCrdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrganizationCrdRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOrganizationCrdRequestWithBody generates requests for CreateOrganizationCrd with any type of body
func NewCreateOrganizationCrdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/crd")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckOrganizationNameAvailabilityRequest generates requests for CheckOrganizationNameAvailability
func NewCheckOrganizationNameAvailabilityRequest(server string, params *CheckOrganizationNameAvailabilityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/name-availability")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slug", runtime.ParamLocationQuery, params.Slug); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationByIdRequest generates requests for GetOrganizationById
func NewGetOrganizationByIdRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListApiKeysRequest generates requests for ListApiKeys
func NewListApiKeysRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/api-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyRequest calls the generic CreateApiKey builder with application/json body
func NewCreateApiKeyRequest(server string, organizationId openapi_types.UUID, body CreateApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateApiKeyRequestWithBody generates requests for CreateApiKey with any type of body
func NewCreateApiKeyRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/api-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeApiKeyRequest generates requests for RevokeApiKey
func NewRevokeApiKeyRequest(server string, organizationId openapi_types.UUID, keyId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key_id", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/api-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOrganizationCrdRequest generates requests for DeleteOrganizationCrd
func NewDeleteOrganizationCrdRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/crd", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListHarborsRequest generates requests for ListHarbors
func NewListHarborsRequest(server string, organizationId openapi_types.UUID, params *ListHarborsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/harbors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Slug != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slug", runtime.ParamLocationQuery, *params.Slug); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHarborCrdRequest calls the generic CreateHarborCrd builder with application/json body
func NewCreateHarborCrdRequest(server string, organizationId openapi_types.UUID, body CreateHarborCrdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHarborCrdRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateHarborCrdRequestWithBody generates requests for CreateHarborCrd with any type of body
func NewCreateHarborCrdRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/harbors/crd", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHarborCrdRequest generates requests for DeleteHarborCrd
func NewDeleteHarborCrdRequest(server string, organizationId openapi_types.UUID, harborSlug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "harbor_slug", runtime.ParamLocationPath, harborSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/harbors/crd/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckHarborNameAvailableRequest generates requests for CheckHarborNameAvailable
func NewCheckHarborNameAvailableRequest(server string, organizationId openapi_types.UUID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/harbors/%s/available", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListModelServingsRequest generates requests for ListModelServings
func NewListModelServingsRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/model-servings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModelServingRequest calls the generic CreateModelServing builder with application/json body
func NewCreateModelServingRequest(server string, organizationId openapi_types.UUID, body CreateModelServingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModelServingRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateModelServingRequestWithBody generates requests for CreateModelServing with any type of body
func NewCreateModelServingRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/model-servings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModelServingRequest generates requests for DeleteModelServing
func NewDeleteModelServingRequest(server string, organizationId openapi_types.UUID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/model-servings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModelServingRequest generates requests for GetModelServing
func NewGetModelServingRequest(server string, organizationId openapi_types.UUID, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/model-servings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchModelServingRequest calls the generic PatchModelServing builder with application/json body
func NewPatchModelServingRequest(server string, organizationId openapi_types.UUID, name string, body PatchModelServingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchModelServingRequestWithBody(server, organizationId, name, "application/json", bodyReader)
}

// NewPatchModelServingRequestWithBody generates requests for PatchModelServing with any type of body
func NewPatchModelServingRequestWithBody(server string, organizationId openapi_types.UUID, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/model-servings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPipelinesRequest generates requests for ListPipelines
func NewListPipelinesRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/pipelines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePipelineRequest generates requests for DeletePipeline
func NewDeletePipelineRequest(server string, organizationId openapi_types.UUID, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/pipelines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPipelineRunsRequest generates requests for ListPipelineRuns
func NewListPipelineRunsRequest(server string, organizationId openapi_types.UUID, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/pipelines/%s/runs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineRunRequest generates requests for GetPipelineRun
func NewGetPipelineRunRequest(server string, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, runId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/pipelines/%s/runs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTriggerPipelineRequest generates requests for TriggerPipeline
func NewTriggerPipelineRequest(server string, organizationId openapi_types.UUID, pipelineId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pipeline_id", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/pipelines/%s/trigger", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceAccountCrdRequest calls the generic CreateServiceAccountCrd builder with application/json body
func NewCreateServiceAccountCrdRequest(server string, organizationId openapi_types.UUID, body CreateServiceAccountCrdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountCrdRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateServiceAccountCrdRequestWithBody generates requests for CreateServiceAccountCrd with any type of body
func NewCreateServiceAccountCrdRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/service-accounts/crd", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountCrdRequest generates requests for DeleteServiceAccountCrd
func NewDeleteServiceAccountCrdRequest(server string, organizationId openapi_types.UUID, clientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/service-accounts/crd/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceAccountCrdRequest calls the generic UpdateServiceAccountCrd builder with application/json body
func NewUpdateServiceAccountCrdRequest(server string, organizationId openapi_types.UUID, clientId string, body UpdateServiceAccountCrdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceAccountCrdRequestWithBody(server, organizationId, clientId, "application/json", bodyReader)
}

// NewUpdateServiceAccountCrdRequestWithBody generates requests for UpdateServiceAccountCrd with any type of body
func NewUpdateServiceAccountCrdRequestWithBody(server string, organizationId openapi_types.UUID, clientId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/service-accounts/crd/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOrgUserAttributesHandlerRequest generates requests for ListOrgUserAttributesHandler
func NewListOrgUserAttributesHandlerRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/user-attributes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOrgUsersRequest generates requests for ListOrgUsers
func NewListOrgUsersRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserToOrganizationRequest calls the generic AddUserToOrganization builder with application/json body
func NewAddUserToOrganizationRequest(server string, organizationId openapi_types.UUID, body AddUserToOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserToOrganizationRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewAddUserToOrganizationRequestWithBody generates requests for AddUserToOrganization with any type of body
func NewAddUserToOrganizationRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUserFromOrganizationRequest generates requests for RemoveUserFromOrganization
func NewRemoveUserFromOrganizationRequest(server string, organizationId openapi_types.UUID, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserAttributesHandlerRequest generates requests for ListUserAttributesHandler
func NewListUserAttributesHandlerRequest(server string, organizationId openapi_types.UUID, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/users/%s/attributes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserAttributeHandlerRequest calls the generic AddUserAttributeHandler builder with application/json body
func NewAddUserAttributeHandlerRequest(server string, organizationId openapi_types.UUID, userId openapi_types.UUID, body AddUserAttributeHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserAttributeHandlerRequestWithBody(server, organizationId, userId, "application/json", bodyReader)
}

// NewAddUserAttributeHandlerRequestWithBody generates requests for AddUserAttributeHandler with any type of body
func NewAddUserAttributeHandlerRequestWithBody(server string, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/users/%s/attributes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetUserAttributesHandlerRequest calls the generic SetUserAttributesHandler builder with application/json body
func NewSetUserAttributesHandlerRequest(server string, organizationId openapi_types.UUID, userId openapi_types.UUID, body SetUserAttributesHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetUserAttributesHandlerRequestWithBody(server, organizationId, userId, "application/json", bodyReader)
}

// NewSetUserAttributesHandlerRequestWithBody generates requests for SetUserAttributesHandler with any type of body
func NewSetUserAttributesHandlerRequestWithBody(server string, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/users/%s/attributes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveUserAttributeHandlerRequest generates requests for RemoveUserAttributeHandler
func NewRemoveUserAttributeHandlerRequest(server string, organizationId openapi_types.UUID, userId openapi_types.UUID, attribute string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "attribute", runtime.ParamLocationPath, attribute)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organizations/%s/users/%s/attributes/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContextProvidersHandlerRequest generates requests for ListContextProvidersHandler
func NewListContextProvidersHandlerRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/context-providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateContextProviderHandlerRequest calls the generic CreateContextProviderHandler builder with application/json body
func NewCreateContextProviderHandlerRequest(server string, organizationId openapi_types.UUID, body CreateContextProviderHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContextProviderHandlerRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateContextProviderHandlerRequestWithBody generates requests for CreateContextProviderHandler with any type of body
func NewCreateContextProviderHandlerRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/context-providers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListContextualRestrictionsHandlerRequest generates requests for ListContextualRestrictionsHandler
func NewListContextualRestrictionsHandlerRequest(server string, organizationId openapi_types.UUID, params *ListContextualRestrictionsHandlerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/contextual-restrictions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DataDockId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_dock_id", runtime.ParamLocationQuery, *params.DataDockId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateContextualRestrictionHandlerRequest calls the generic CreateContextualRestrictionHandler builder with application/json body
func NewCreateContextualRestrictionHandlerRequest(server string, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, body CreateContextualRestrictionHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContextualRestrictionHandlerRequestWithBody(server, organizationId, params, "application/json", bodyReader)
}

// NewCreateContextualRestrictionHandlerRequestWithBody generates requests for CreateContextualRestrictionHandler with any type of body
func NewCreateContextualRestrictionHandlerRequestWithBody(server string, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/contextual-restrictions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DataDockId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_dock_id", runtime.ParamLocationQuery, *params.DataDockId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDataDocksRequest generates requests for ListDataDocks
func NewListDataDocksRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/data-docks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshOrgDataDocksRequest generates requests for RefreshOrgDataDocks
func NewRefreshOrgDataDocksRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/data-docks/refresh", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEffectiveSecuritySettingsHandlerRequest generates requests for GetEffectiveSecuritySettingsHandler
func NewGetEffectiveSecuritySettingsHandlerRequest(server string, organizationId openapi_types.UUID, dataDockId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/data-docks/%s/security/effective", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrgSecuritySettingsHandlerRequest generates requests for GetOrgSecuritySettingsHandler
func NewGetOrgSecuritySettingsHandlerRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/security/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrgSecuritySettingsHandlerRequest calls the generic UpdateOrgSecuritySettingsHandler builder with application/json body
func NewUpdateOrgSecuritySettingsHandlerRequest(server string, organizationId openapi_types.UUID, body UpdateOrgSecuritySettingsHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrgSecuritySettingsHandlerRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewUpdateOrgSecuritySettingsHandlerRequestWithBody generates requests for UpdateOrgSecuritySettingsHandler with any type of body
func NewUpdateOrgSecuritySettingsHandlerRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/security/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListServiceAccountsHandlerRequest generates requests for ListServiceAccountsHandler
func NewListServiceAccountsHandlerRequest(server string, organizationId openapi_types.UUID, params *ListServiceAccountsHandlerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadServiceAccountHandlerRequest generates requests for DownloadServiceAccountHandler
func NewDownloadServiceAccountHandlerRequest(server string, organizationId openapi_types.UUID, serviceAccountId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "service_account_id", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/service-accounts/%s/download", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTableClassificationsHandlerRequest generates requests for ListTableClassificationsHandler
func NewListTableClassificationsHandlerRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/table-classifications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableClassificationHandlerRequest calls the generic CreateTableClassificationHandler builder with application/json body
func NewCreateTableClassificationHandlerRequest(server string, organizationId openapi_types.UUID, body CreateTableClassificationHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableClassificationHandlerRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewCreateTableClassificationHandlerRequestWithBody generates requests for CreateTableClassificationHandler with any type of body
func NewCreateTableClassificationHandlerRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/table-classifications", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAiClassifyHandlerRequest calls the generic AiClassifyHandler builder with application/json body
func NewAiClassifyHandlerRequest(server string, organizationId openapi_types.UUID, body AiClassifyHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAiClassifyHandlerRequestWithBody(server, organizationId, "application/json", bodyReader)
}

// NewAiClassifyHandlerRequestWithBody generates requests for AiClassifyHandler with any type of body
func NewAiClassifyHandlerRequestWithBody(server string, organizationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/table-classifications/ai-classify", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTableClassificationStatsHandlerRequest generates requests for GetTableClassificationStatsHandler
func NewGetTableClassificationStatsHandlerRequest(server string, organizationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/table-classifications/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTableClassificationHandlerRequest generates requests for DeleteTableClassificationHandler
func NewDeleteTableClassificationHandlerRequest(server string, organizationId openapi_types.UUID, classificationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "classification_id", runtime.ParamLocationPath, classificationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/table-classifications/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTableClassificationHandlerRequest calls the generic UpdateTableClassificationHandler builder with application/json body
func NewUpdateTableClassificationHandlerRequest(server string, organizationId openapi_types.UUID, classificationId openapi_types.UUID, body UpdateTableClassificationHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTableClassificationHandlerRequestWithBody(server, organizationId, classificationId, "application/json", bodyReader)
}

// NewUpdateTableClassificationHandlerRequestWithBody generates requests for UpdateTableClassificationHandler with any type of body
func NewUpdateTableClassificationHandlerRequestWithBody(server string, organizationId openapi_types.UUID, classificationId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "classification_id", runtime.ParamLocationPath, classificationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/table-classifications/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserContextHandlerRequest generates requests for GetUserContextHandler
func NewGetUserContextHandlerRequest(server string, organizationId openapi_types.UUID, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orgs/%s/users/%s/context", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePipelineRequest calls the generic CreatePipeline builder with application/json body
func NewCreatePipelineRequest(server string, body CreatePipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePipelineRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePipelineRequestWithBody generates requests for CreatePipeline with any type of body
func NewCreatePipelineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCountRefsRequest calls the generic CountRefs builder with application/json body
func NewCountRefsRequest(server string, body CountRefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCountRefsRequestWithBody(server, "application/json", bodyReader)
}

// NewCountRefsRequestWithBody generates requests for CountRefs with any type of body
func NewCountRefsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/refs/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRefsRequest generates requests for ListRefs
func NewListRefsRequest(server string, params *ListRefsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/refs/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PipelineId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_id", runtime.ParamLocationQuery, *params.PipelineId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineChecksum != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipeline_checksum", runtime.ParamLocationQuery, *params.PipelineChecksum); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAtBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at_before", runtime.ParamLocationQuery, *params.UpdatedAtBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAtAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_at_after", runtime.ParamLocationQuery, *params.UpdatedAtAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Lock != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lock", runtime.ParamLocationQuery, *params.Lock); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LockedBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locked_by", runtime.ParamLocationQuery, *params.LockedBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRefRequest calls the generic UpdateRef builder with application/json body
func NewUpdateRefRequest(server string, key string, body UpdateRefJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRefRequestWithBody(server, key, "application/json", bodyReader)
}

// NewUpdateRefRequestWithBody generates requests for UpdateRef with any type of body
func NewUpdateRefRequestWithBody(server string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/refs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelQueryHandlerRequest generates requests for CancelQueryHandler
func NewCancelQueryHandlerRequest(server string, trinoQueryId string, params *CancelQueryHandlerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "trino_query_id", runtime.ParamLocationPath, trinoQueryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/cancel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_dock_id", runtime.ParamLocationQuery, params.DataDockId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecuteQueryHandlerRequest calls the generic ExecuteQueryHandler builder with application/json body
func NewExecuteQueryHandlerRequest(server string, body ExecuteQueryHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteQueryHandlerRequestWithBody(server, "application/json", bodyReader)
}

// NewExecuteQueryHandlerRequestWithBody generates requests for ExecuteQueryHandler with any type of body
func NewExecuteQueryHandlerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/execute")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHistoryHandlerRequest generates requests for GetHistoryHandler
func NewGetHistoryHandlerRequest(server string, params *GetHistoryHandlerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DataDockId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_dock_id", runtime.ParamLocationQuery, *params.DataDockId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatementType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statement_type", runtime.ParamLocationQuery, *params.StatementType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSavedQueriesHandlerRequest generates requests for ListSavedQueriesHandler
func NewListSavedQueriesHandlerRequest(server string, params *ListSavedQueriesHandlerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DataDockId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data_dock_id", runtime.ParamLocationQuery, *params.DataDockId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Visibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mine != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mine", runtime.ParamLocationQuery, *params.Mine); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSavedQueryHandlerRequest calls the generic CreateSavedQueryHandler builder with application/json body
func NewCreateSavedQueryHandlerRequest(server string, body CreateSavedQueryHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSavedQueryHandlerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSavedQueryHandlerRequestWithBody generates requests for CreateSavedQueryHandler with any type of body
func NewCreateSavedQueryHandlerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/queries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSavedQueryHandlerRequest generates requests for DeleteSavedQueryHandler
func NewDeleteSavedQueryHandlerRequest(server string, queryId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSavedQueryHandlerRequest generates requests for GetSavedQueryHandler
func NewGetSavedQueryHandlerRequest(server string, queryId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSavedQueryHandlerRequest calls the generic UpdateSavedQueryHandler builder with application/json body
func NewUpdateSavedQueryHandlerRequest(server string, queryId openapi_types.UUID, body UpdateSavedQueryHandlerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSavedQueryHandlerRequestWithBody(server, queryId, "application/json", bodyReader)
}

// NewUpdateSavedQueryHandlerRequestWithBody generates requests for UpdateSavedQueryHandler with any type of body
func NewUpdateSavedQueryHandlerRequestWithBody(server string, queryId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/queries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetResultsHandlerRequest generates requests for GetResultsHandler
func NewGetResultsHandlerRequest(server string, queryId openapi_types.UUID, params *GetResultsHandlerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query_id", runtime.ParamLocationPath, queryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/results/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemaHandlerRequest generates requests for GetSchemaHandler
func NewGetSchemaHandlerRequest(server string, dataDockId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "data_dock_id", runtime.ParamLocationPath, dataDockId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tiny-query/schema/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnifiedCatalogRequest generates requests for GetUnifiedCatalog
func NewGetUnifiedCatalogRequest(server string, params *GetUnifiedCatalogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/unified-catalog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.HarborId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "harbor_id", runtime.ParamLocationQuery, *params.HarborId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePipelineV2Request calls the generic CreatePipelineV2 builder with application/json body
func NewCreatePipelineV2Request(server string, body CreatePipelineV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePipelineV2RequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePipelineV2RequestWithBody generates requests for CreatePipelineV2 with any type of body
func NewCreatePipelineV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// HandleGetConsoleConfigWithResponse request
	HandleGetConsoleConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HandleGetConsoleConfigRes, error)

	// DeleteContextProviderHandlerWithResponse request
	DeleteContextProviderHandlerWithResponse(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteContextProviderHandlerRes, error)

	// GetContextProviderHandlerWithResponse request
	GetContextProviderHandlerWithResponse(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetContextProviderHandlerRes, error)

	// UpdateContextProviderHandlerWithBodyWithResponse request with any body
	UpdateContextProviderHandlerWithBodyWithResponse(ctx context.Context, providerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContextProviderHandlerRes, error)

	UpdateContextProviderHandlerWithResponse(ctx context.Context, providerId openapi_types.UUID, body UpdateContextProviderHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContextProviderHandlerRes, error)

	// SyncContextProviderHandlerWithResponse request
	SyncContextProviderHandlerWithResponse(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*SyncContextProviderHandlerRes, error)

	// DeleteContextualRestrictionHandlerWithResponse request
	DeleteContextualRestrictionHandlerWithResponse(ctx context.Context, restrictionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteContextualRestrictionHandlerRes, error)

	// GetContextualRestrictionHandlerWithResponse request
	GetContextualRestrictionHandlerWithResponse(ctx context.Context, restrictionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetContextualRestrictionHandlerRes, error)

	// UpdateContextualRestrictionHandlerWithBodyWithResponse request with any body
	UpdateContextualRestrictionHandlerWithBodyWithResponse(ctx context.Context, restrictionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContextualRestrictionHandlerRes, error)

	UpdateContextualRestrictionHandlerWithResponse(ctx context.Context, restrictionId openapi_types.UUID, body UpdateContextualRestrictionHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContextualRestrictionHandlerRes, error)

	// CreateBucketDataContainerWithBodyWithResponse request with any body
	CreateBucketDataContainerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBucketDataContainerRes, error)

	CreateBucketDataContainerWithResponse(ctx context.Context, body CreateBucketDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBucketDataContainerRes, error)

	// DeleteBucketFileWithResponse request
	DeleteBucketFileWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, params *DeleteBucketFileParams, reqEditors ...RequestEditorFn) (*DeleteBucketFileRes, error)

	// ListBucketFilesWithResponse request
	ListBucketFilesWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, params *ListBucketFilesParams, reqEditors ...RequestEditorFn) (*ListBucketFilesRes, error)

	// UploadBucketFileWithResponse request
	UploadBucketFileWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*UploadBucketFileRes, error)

	// DownloadBucketFileWithResponse request
	DownloadBucketFileWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, params *DownloadBucketFileParams, reqEditors ...RequestEditorFn) (*DownloadBucketFileRes, error)

	// CreateBucketFolderWithBodyWithResponse request with any body
	CreateBucketFolderWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBucketFolderRes, error)

	CreateBucketFolderWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CreateBucketFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBucketFolderRes, error)

	// GetBucketStatsWithResponse request
	GetBucketStatsWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetBucketStatsRes, error)

	// GetFakerFieldTypesWithResponse request
	GetFakerFieldTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFakerFieldTypesRes, error)

	// GetFakerSchemasWithResponse request
	GetFakerSchemasWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFakerSchemasRes, error)

	// CreateFakerSchemaWithBodyWithResponse request with any body
	CreateFakerSchemaWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFakerSchemaRes, error)

	CreateFakerSchemaWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CreateFakerSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFakerSchemaRes, error)

	// DeleteFakerSchemaWithResponse request
	DeleteFakerSchemaWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFakerSchemaRes, error)

	// CreateFakerTableWithBodyWithResponse request with any body
	CreateFakerTableWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFakerTableRes, error)

	CreateFakerTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFakerTableRes, error)

	// CreateFakerTableStructuredWithBodyWithResponse request with any body
	CreateFakerTableStructuredWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFakerTableStructuredRes, error)

	CreateFakerTableStructuredWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableStructuredJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFakerTableStructuredRes, error)

	// GetFakerTablesWithResponse request
	GetFakerTablesWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFakerTablesRes, error)

	// DeleteFakerTableWithResponse request
	DeleteFakerTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFakerTableRes, error)

	// GetFakerTableWithResponse request
	GetFakerTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFakerTableRes, error)

	// UpdateFakerTableWithBodyWithResponse request with any body
	UpdateFakerTableWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFakerTableRes, error)

	UpdateFakerTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, body UpdateFakerTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFakerTableRes, error)

	// CreateIcebergDataContainerWithBodyWithResponse request with any body
	CreateIcebergDataContainerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIcebergDataContainerRes, error)

	CreateIcebergDataContainerWithResponse(ctx context.Context, body CreateIcebergDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIcebergDataContainerRes, error)

	// GetIcebergDataContainerWithResponse request
	GetIcebergDataContainerWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetIcebergDataContainerRes, error)

	// GetSchemasWithResponse request
	GetSchemasWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSchemasRes, error)

	// CreateSchemaWithBodyWithResponse request with any body
	CreateSchemaWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchemaRes, error)

	CreateSchemaWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchemaRes, error)

	// GetTablesWithResponse request
	GetTablesWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetTablesRes, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableRes, error)

	CreateTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableRes, error)

	// CloneTableWithBodyWithResponse request with any body
	CloneTableWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneTableRes, error)

	CloneTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CloneTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneTableRes, error)

	// DeleteDataContainerWithResponse request
	DeleteDataContainerWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDataContainerRes, error)

	// GetDataContainerWithResponse request
	GetDataContainerWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDataContainerRes, error)

	// CreateDataDockCrdWithBodyWithResponse request with any body
	CreateDataDockCrdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataDockCrdRes, error)

	CreateDataDockCrdWithResponse(ctx context.Context, body CreateDataDockCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataDockCrdRes, error)

	// DeleteDataDockCrdWithResponse request
	DeleteDataDockCrdWithResponse(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDataDockCrdRes, error)

	// ListDataContainersWithResponse request
	ListDataContainersWithResponse(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListDataContainersRes, error)

	// ArchiveExportDataContainerWithBodyWithResponse request with any body
	ArchiveExportDataContainerWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveExportDataContainerRes, error)

	ArchiveExportDataContainerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveExportDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveExportDataContainerRes, error)

	// ArchiveImportDataContainerWithBodyWithResponse request with any body
	ArchiveImportDataContainerWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveImportDataContainerRes, error)

	ArchiveImportDataContainerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveImportDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveImportDataContainerRes, error)

	// AbortMultipartUploadWithBodyWithResponse request with any body
	AbortMultipartUploadWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortMultipartUploadRes, error)

	AbortMultipartUploadWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body AbortMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortMultipartUploadRes, error)

	// CompleteMultipartUploadWithBodyWithResponse request with any body
	CompleteMultipartUploadWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteMultipartUploadRes, error)

	CompleteMultipartUploadWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body CompleteMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteMultipartUploadRes, error)

	// PrepareArchiveImportWithBodyWithResponse request with any body
	PrepareArchiveImportWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareArchiveImportRes, error)

	PrepareArchiveImportWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body PrepareArchiveImportJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareArchiveImportRes, error)

	// ListArchiveOperationsWithResponse request
	ListArchiveOperationsWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, params *ListArchiveOperationsParams, reqEditors ...RequestEditorFn) (*ListArchiveOperationsRes, error)

	// GetArchiveOperationWithResponse request
	GetArchiveOperationWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetArchiveOperationRes, error)

	// DownloadArchiveOperationWithResponse request
	DownloadArchiveOperationWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, params *DownloadArchiveOperationParams, reqEditors ...RequestEditorFn) (*DownloadArchiveOperationRes, error)

	// GetDataDockSecuritySettingsHandlerWithResponse request
	GetDataDockSecuritySettingsHandlerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDataDockSecuritySettingsHandlerRes, error)

	// UpdateDataDockSecuritySettingsHandlerWithBodyWithResponse request with any body
	UpdateDataDockSecuritySettingsHandlerWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataDockSecuritySettingsHandlerRes, error)

	UpdateDataDockSecuritySettingsHandlerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, body UpdateDataDockSecuritySettingsHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataDockSecuritySettingsHandlerRes, error)

	// ListHarborDataDockWithResponse request
	ListHarborDataDockWithResponse(ctx context.Context, harborId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListHarborDataDockRes, error)

	// ListOrganizationsWithResponse request
	ListOrganizationsWithResponse(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*ListOrganizationsRes, error)

	// CreateOrganizationCrdWithBodyWithResponse request with any body
	CreateOrganizationCrdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationCrdRes, error)

	CreateOrganizationCrdWithResponse(ctx context.Context, body CreateOrganizationCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationCrdRes, error)

	// CheckOrganizationNameAvailabilityWithResponse request
	CheckOrganizationNameAvailabilityWithResponse(ctx context.Context, params *CheckOrganizationNameAvailabilityParams, reqEditors ...RequestEditorFn) (*CheckOrganizationNameAvailabilityRes, error)

	// GetOrganizationByIdWithResponse request
	GetOrganizationByIdWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetOrganizationByIdRes, error)

	// ListApiKeysWithResponse request
	ListApiKeysWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListApiKeysRes, error)

	// CreateApiKeyWithBodyWithResponse request with any body
	CreateApiKeyWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyRes, error)

	CreateApiKeyWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyRes, error)

	// RevokeApiKeyWithResponse request
	RevokeApiKeyWithResponse(ctx context.Context, organizationId openapi_types.UUID, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*RevokeApiKeyRes, error)

	// DeleteOrganizationCrdWithResponse request
	DeleteOrganizationCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteOrganizationCrdRes, error)

	// ListHarborsWithResponse request
	ListHarborsWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListHarborsParams, reqEditors ...RequestEditorFn) (*ListHarborsRes, error)

	// CreateHarborCrdWithBodyWithResponse request with any body
	CreateHarborCrdWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHarborCrdRes, error)

	CreateHarborCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateHarborCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHarborCrdRes, error)

	// DeleteHarborCrdWithResponse request
	DeleteHarborCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, harborSlug string, reqEditors ...RequestEditorFn) (*DeleteHarborCrdRes, error)

	// CheckHarborNameAvailableWithResponse request
	CheckHarborNameAvailableWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*CheckHarborNameAvailableRes, error)

	// ListModelServingsWithResponse request
	ListModelServingsWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListModelServingsRes, error)

	// CreateModelServingWithBodyWithResponse request with any body
	CreateModelServingWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelServingRes, error)

	CreateModelServingWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateModelServingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelServingRes, error)

	// DeleteModelServingWithResponse request
	DeleteModelServingWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*DeleteModelServingRes, error)

	// GetModelServingWithResponse request
	GetModelServingWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*GetModelServingRes, error)

	// PatchModelServingWithBodyWithResponse request with any body
	PatchModelServingWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchModelServingRes, error)

	PatchModelServingWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, body PatchModelServingJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchModelServingRes, error)

	// ListPipelinesWithResponse request
	ListPipelinesWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListPipelinesRes, error)

	// DeletePipelineWithResponse request
	DeletePipelineWithResponse(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeletePipelineRes, error)

	// ListPipelineRunsWithResponse request
	ListPipelineRunsWithResponse(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListPipelineRunsRes, error)

	// GetPipelineRunWithResponse request
	GetPipelineRunWithResponse(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, runId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPipelineRunRes, error)

	// TriggerPipelineWithResponse request
	TriggerPipelineWithResponse(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*TriggerPipelineRes, error)

	// CreateServiceAccountCrdWithBodyWithResponse request with any body
	CreateServiceAccountCrdWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountCrdRes, error)

	CreateServiceAccountCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateServiceAccountCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountCrdRes, error)

	// DeleteServiceAccountCrdWithResponse request
	DeleteServiceAccountCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, clientId string, reqEditors ...RequestEditorFn) (*DeleteServiceAccountCrdRes, error)

	// UpdateServiceAccountCrdWithBodyWithResponse request with any body
	UpdateServiceAccountCrdWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountCrdRes, error)

	UpdateServiceAccountCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, clientId string, body UpdateServiceAccountCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountCrdRes, error)

	// ListOrgUserAttributesHandlerWithResponse request
	ListOrgUserAttributesHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListOrgUserAttributesHandlerRes, error)

	// ListOrgUsersWithResponse request
	ListOrgUsersWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListOrgUsersRes, error)

	// AddUserToOrganizationWithBodyWithResponse request with any body
	AddUserToOrganizationWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToOrganizationRes, error)

	AddUserToOrganizationWithResponse(ctx context.Context, organizationId openapi_types.UUID, body AddUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToOrganizationRes, error)

	// RemoveUserFromOrganizationWithResponse request
	RemoveUserFromOrganizationWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*RemoveUserFromOrganizationRes, error)

	// ListUserAttributesHandlerWithResponse request
	ListUserAttributesHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListUserAttributesHandlerRes, error)

	// AddUserAttributeHandlerWithBodyWithResponse request with any body
	AddUserAttributeHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserAttributeHandlerRes, error)

	AddUserAttributeHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, body AddUserAttributeHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserAttributeHandlerRes, error)

	// SetUserAttributesHandlerWithBodyWithResponse request with any body
	SetUserAttributesHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetUserAttributesHandlerRes, error)

	SetUserAttributesHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, body SetUserAttributesHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetUserAttributesHandlerRes, error)

	// RemoveUserAttributeHandlerWithResponse request
	RemoveUserAttributeHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, attribute string, reqEditors ...RequestEditorFn) (*RemoveUserAttributeHandlerRes, error)

	// ListContextProvidersHandlerWithResponse request
	ListContextProvidersHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListContextProvidersHandlerRes, error)

	// CreateContextProviderHandlerWithBodyWithResponse request with any body
	CreateContextProviderHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContextProviderHandlerRes, error)

	CreateContextProviderHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateContextProviderHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContextProviderHandlerRes, error)

	// ListContextualRestrictionsHandlerWithResponse request
	ListContextualRestrictionsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListContextualRestrictionsHandlerParams, reqEditors ...RequestEditorFn) (*ListContextualRestrictionsHandlerRes, error)

	// CreateContextualRestrictionHandlerWithBodyWithResponse request with any body
	CreateContextualRestrictionHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContextualRestrictionHandlerRes, error)

	CreateContextualRestrictionHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, body CreateContextualRestrictionHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContextualRestrictionHandlerRes, error)

	// ListDataDocksWithResponse request
	ListDataDocksWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListDataDocksRes, error)

	// RefreshOrgDataDocksWithResponse request
	RefreshOrgDataDocksWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*RefreshOrgDataDocksRes, error)

	// GetEffectiveSecuritySettingsHandlerWithResponse request
	GetEffectiveSecuritySettingsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetEffectiveSecuritySettingsHandlerRes, error)

	// GetOrgSecuritySettingsHandlerWithResponse request
	GetOrgSecuritySettingsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetOrgSecuritySettingsHandlerRes, error)

	// UpdateOrgSecuritySettingsHandlerWithBodyWithResponse request with any body
	UpdateOrgSecuritySettingsHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgSecuritySettingsHandlerRes, error)

	UpdateOrgSecuritySettingsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, body UpdateOrgSecuritySettingsHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgSecuritySettingsHandlerRes, error)

	// ListServiceAccountsHandlerWithResponse request
	ListServiceAccountsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListServiceAccountsHandlerParams, reqEditors ...RequestEditorFn) (*ListServiceAccountsHandlerRes, error)

	// DownloadServiceAccountHandlerWithResponse request
	DownloadServiceAccountHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, serviceAccountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DownloadServiceAccountHandlerRes, error)

	// ListTableClassificationsHandlerWithResponse request
	ListTableClassificationsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListTableClassificationsHandlerRes, error)

	// CreateTableClassificationHandlerWithBodyWithResponse request with any body
	CreateTableClassificationHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableClassificationHandlerRes, error)

	CreateTableClassificationHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateTableClassificationHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableClassificationHandlerRes, error)

	// AiClassifyHandlerWithBodyWithResponse request with any body
	AiClassifyHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AiClassifyHandlerRes, error)

	AiClassifyHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, body AiClassifyHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*AiClassifyHandlerRes, error)

	// GetTableClassificationStatsHandlerWithResponse request
	GetTableClassificationStatsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetTableClassificationStatsHandlerRes, error)

	// DeleteTableClassificationHandlerWithResponse request
	DeleteTableClassificationHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteTableClassificationHandlerRes, error)

	// UpdateTableClassificationHandlerWithBodyWithResponse request with any body
	UpdateTableClassificationHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableClassificationHandlerRes, error)

	UpdateTableClassificationHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, body UpdateTableClassificationHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableClassificationHandlerRes, error)

	// GetUserContextHandlerWithResponse request
	GetUserContextHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId string, reqEditors ...RequestEditorFn) (*GetUserContextHandlerRes, error)

	// CreatePipelineWithBodyWithResponse request with any body
	CreatePipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineRes, error)

	CreatePipelineWithResponse(ctx context.Context, body CreatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineRes, error)

	// CountRefsWithBodyWithResponse request with any body
	CountRefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CountRefsRes, error)

	CountRefsWithResponse(ctx context.Context, body CountRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*CountRefsRes, error)

	// ListRefsWithResponse request
	ListRefsWithResponse(ctx context.Context, params *ListRefsParams, reqEditors ...RequestEditorFn) (*ListRefsRes, error)

	// UpdateRefWithBodyWithResponse request with any body
	UpdateRefWithBodyWithResponse(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRefRes, error)

	UpdateRefWithResponse(ctx context.Context, key string, body UpdateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRefRes, error)

	// CancelQueryHandlerWithResponse request
	CancelQueryHandlerWithResponse(ctx context.Context, trinoQueryId string, params *CancelQueryHandlerParams, reqEditors ...RequestEditorFn) (*CancelQueryHandlerRes, error)

	// ExecuteQueryHandlerWithBodyWithResponse request with any body
	ExecuteQueryHandlerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteQueryHandlerRes, error)

	ExecuteQueryHandlerWithResponse(ctx context.Context, body ExecuteQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteQueryHandlerRes, error)

	// GetHistoryHandlerWithResponse request
	GetHistoryHandlerWithResponse(ctx context.Context, params *GetHistoryHandlerParams, reqEditors ...RequestEditorFn) (*GetHistoryHandlerRes, error)

	// ListSavedQueriesHandlerWithResponse request
	ListSavedQueriesHandlerWithResponse(ctx context.Context, params *ListSavedQueriesHandlerParams, reqEditors ...RequestEditorFn) (*ListSavedQueriesHandlerRes, error)

	// CreateSavedQueryHandlerWithBodyWithResponse request with any body
	CreateSavedQueryHandlerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSavedQueryHandlerRes, error)

	CreateSavedQueryHandlerWithResponse(ctx context.Context, body CreateSavedQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSavedQueryHandlerRes, error)

	// DeleteSavedQueryHandlerWithResponse request
	DeleteSavedQueryHandlerWithResponse(ctx context.Context, queryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSavedQueryHandlerRes, error)

	// GetSavedQueryHandlerWithResponse request
	GetSavedQueryHandlerWithResponse(ctx context.Context, queryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSavedQueryHandlerRes, error)

	// UpdateSavedQueryHandlerWithBodyWithResponse request with any body
	UpdateSavedQueryHandlerWithBodyWithResponse(ctx context.Context, queryId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSavedQueryHandlerRes, error)

	UpdateSavedQueryHandlerWithResponse(ctx context.Context, queryId openapi_types.UUID, body UpdateSavedQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSavedQueryHandlerRes, error)

	// GetResultsHandlerWithResponse request
	GetResultsHandlerWithResponse(ctx context.Context, queryId openapi_types.UUID, params *GetResultsHandlerParams, reqEditors ...RequestEditorFn) (*GetResultsHandlerRes, error)

	// GetSchemaHandlerWithResponse request
	GetSchemaHandlerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSchemaHandlerRes, error)

	// GetUnifiedCatalogWithResponse request
	GetUnifiedCatalogWithResponse(ctx context.Context, params *GetUnifiedCatalogParams, reqEditors ...RequestEditorFn) (*GetUnifiedCatalogRes, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserRes, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserRes, error)

	// CreatePipelineV2WithBodyWithResponse request with any body
	CreatePipelineV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineV2Res, error)

	CreatePipelineV2WithResponse(ctx context.Context, body CreatePipelineV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineV2Res, error)
}

type HandleGetConsoleConfigRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetConsoleConfigResponse
}

// Status returns HTTPResponse.Status
func (r HandleGetConsoleConfigRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HandleGetConsoleConfigRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContextProviderHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteContextProviderHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContextProviderHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContextProviderHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContextProviderResponse
}

// Status returns HTTPResponse.Status
func (r GetContextProviderHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContextProviderHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateContextProviderHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContextProviderResponse
}

// Status returns HTTPResponse.Status
func (r UpdateContextProviderHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateContextProviderHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncContextProviderHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SyncContextProviderHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncContextProviderHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContextualRestrictionHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteContextualRestrictionHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContextualRestrictionHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContextualRestrictionHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContextualRestrictionResponse
}

// Status returns HTTPResponse.Status
func (r GetContextualRestrictionHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContextualRestrictionHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateContextualRestrictionHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContextualRestrictionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateContextualRestrictionHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateContextualRestrictionHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBucketDataContainerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DataContainerOverview
}

// Status returns HTTPResponse.Status
func (r CreateBucketDataContainerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBucketDataContainerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBucketFileRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBucketFileRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBucketFileRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBucketFilesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BucketFile
}

// Status returns HTTPResponse.Status
func (r ListBucketFilesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBucketFilesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadBucketFileRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UploadBucketFileRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadBucketFileRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadBucketFileRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadBucketFileRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadBucketFileRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBucketFolderRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBucketFolderRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBucketFolderRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBucketStatsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketStats
}

// Status returns HTTPResponse.Status
func (r GetBucketStatsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBucketStatsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFakerFieldTypesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFakerFieldTypesResponse
}

// Status returns HTTPResponse.Status
func (r GetFakerFieldTypesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFakerFieldTypesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFakerSchemasRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFakerSchemaResponse
}

// Status returns HTTPResponse.Status
func (r GetFakerSchemasRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFakerSchemasRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFakerSchemaRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FakerSchemaOverview
}

// Status returns HTTPResponse.Status
func (r CreateFakerSchemaRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFakerSchemaRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFakerSchemaRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFakerSchemaRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFakerSchemaRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFakerTableRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FakerTableOverview
}

// Status returns HTTPResponse.Status
func (r CreateFakerTableRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFakerTableRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFakerTableStructuredRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FakerTableOverview
}

// Status returns HTTPResponse.Status
func (r CreateFakerTableStructuredRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFakerTableStructuredRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFakerTablesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFakerTablesResponse
}

// Status returns HTTPResponse.Status
func (r GetFakerTablesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFakerTablesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFakerTableRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFakerTableRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFakerTableRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFakerTableRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFakerTableResponse
}

// Status returns HTTPResponse.Status
func (r GetFakerTableRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFakerTableRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFakerTableRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FakerTableOverview
}

// Status returns HTTPResponse.Status
func (r UpdateFakerTableRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFakerTableRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIcebergDataContainerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DataContainerOverview
}

// Status returns HTTPResponse.Status
func (r CreateIcebergDataContainerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIcebergDataContainerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIcebergDataContainerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IcebergConnectorDataContainer
}

// Status returns HTTPResponse.Status
func (r GetIcebergDataContainerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIcebergDataContainerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemasRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IcebergSchemaMetadata
}

// Status returns HTTPResponse.Status
func (r GetSchemasRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemasRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSchemaRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IcebergSchemaMetadata
}

// Status returns HTTPResponse.Status
func (r CreateSchemaRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSchemaRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTablesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IcebergTableResponseData
}

// Status returns HTTPResponse.Status
func (r GetTablesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTablesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IcebergTableMetadata
}

// Status returns HTTPResponse.Status
func (r CreateTableRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloneTableRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CloneTableRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloneTableRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataContainerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDataContainerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataContainerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataContainerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataContainerOverview
}

// Status returns HTTPResponse.Status
func (r GetDataContainerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataContainerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDataDockCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DataDockResponseData
}

// Status returns HTTPResponse.Status
func (r CreateDataDockCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDataDockCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataDockCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDataDockCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataDockCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDataContainersRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DataContainerOverview
}

// Status returns HTTPResponse.Status
func (r ListDataContainersRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDataContainersRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveExportDataContainerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketArchiveOperation
}

// Status returns HTTPResponse.Status
func (r ArchiveExportDataContainerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveExportDataContainerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveImportDataContainerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketArchiveOperation
}

// Status returns HTTPResponse.Status
func (r ArchiveImportDataContainerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveImportDataContainerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbortMultipartUploadRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AbortMultipartUploadRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbortMultipartUploadRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteMultipartUploadRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CompleteMultipartUploadRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteMultipartUploadRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareArchiveImportRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrepareArchiveImportResponse
}

// Status returns HTTPResponse.Status
func (r PrepareArchiveImportRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareArchiveImportRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListArchiveOperationsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BucketArchiveOperation
}

// Status returns HTTPResponse.Status
func (r ListArchiveOperationsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListArchiveOperationsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArchiveOperationRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketArchiveOperation
}

// Status returns HTTPResponse.Status
func (r GetArchiveOperationRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArchiveOperationRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadArchiveOperationRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArchiveDownloadResponse
}

// Status returns HTTPResponse.Status
func (r DownloadArchiveOperationRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadArchiveOperationRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataDockSecuritySettingsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataDockSecuritySettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetDataDockSecuritySettingsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataDockSecuritySettingsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDataDockSecuritySettingsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataDockSecuritySettingsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateDataDockSecuritySettingsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDataDockSecuritySettingsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHarborDataDockRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Harbor
}

// Status returns HTTPResponse.Status
func (r ListHarborDataDockRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHarborDataDockRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrganizationsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Org
}

// Status returns HTTPResponse.Status
func (r ListOrganizationsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganizationsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrganizationCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateOrganizationCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrganizationCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckOrganizationNameAvailabilityRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckOrganizationNameAvailabilityResponseData
}

// Status returns HTTPResponse.Status
func (r CheckOrganizationNameAvailabilityRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckOrganizationNameAvailabilityRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationByIdRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Org
}

// Status returns HTTPResponse.Status
func (r GetOrganizationByIdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationByIdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListApiKeysRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApiKeyResponse
}

// Status returns HTTPResponse.Status
func (r ListApiKeysRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateApiKeyResponse
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeApiKeyRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RevokeApiKeyRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeApiKeyRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListHarborsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Harbor
}

// Status returns HTTPResponse.Status
func (r ListHarborsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListHarborsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHarborCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Harbor
}

// Status returns HTTPResponse.Status
func (r CreateHarborCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHarborCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHarborCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteHarborCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHarborCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckHarborNameAvailableRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckNameAvailabilityResponseData
}

// Status returns HTTPResponse.Status
func (r CheckHarborNameAvailableRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckHarborNameAvailableRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelServingsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ModelServingResponse
}

// Status returns HTTPResponse.Status
func (r ListModelServingsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelServingsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModelServingRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ModelServingResponse
}

// Status returns HTTPResponse.Status
func (r CreateModelServingRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModelServingRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModelServingRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteModelServingRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModelServingRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModelServingRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelServingResponse
}

// Status returns HTTPResponse.Status
func (r GetModelServingRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModelServingRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchModelServingRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelServingResponse
}

// Status returns HTTPResponse.Status
func (r PatchModelServingRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchModelServingRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPipelinesRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PipelineResponseData
}

// Status returns HTTPResponse.Status
func (r ListPipelinesRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPipelinesRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePipelineRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePipelineRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePipelineRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPipelineRunsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRunsResponse
}

// Status returns HTTPResponse.Status
func (r ListPipelineRunsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPipelineRunsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineRunRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRunResponse
}

// Status returns HTTPResponse.Status
func (r GetPipelineRunRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineRunRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerPipelineRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TriggerPipelineRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerPipelineRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccount
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceAccountCrdRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccount
}

// Status returns HTTPResponse.Status
func (r UpdateServiceAccountCrdRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceAccountCrdRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrgUserAttributesHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgUserAttributesResponse
}

// Status returns HTTPResponse.Status
func (r ListOrgUserAttributesHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrgUserAttributesHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrgUsersRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserWithRoles
}

// Status returns HTTPResponse.Status
func (r ListOrgUsersRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrgUsersRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserToOrganizationRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
}

// Status returns HTTPResponse.Status
func (r AddUserToOrganizationRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserToOrganizationRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserFromOrganizationRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUserFromOrganizationRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserFromOrganizationRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserAttributesHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListUserAttributesResponse
}

// Status returns HTTPResponse.Status
func (r ListUserAttributesHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserAttributesHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserAttributeHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddUserAttributeHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserAttributeHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetUserAttributesHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetUserAttributesHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetUserAttributesHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveUserAttributeHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveUserAttributeHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveUserAttributeHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContextProvidersHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListContextProvidersResponse
}

// Status returns HTTPResponse.Status
func (r ListContextProvidersHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContextProvidersHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContextProviderHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ContextProviderResponse
}

// Status returns HTTPResponse.Status
func (r CreateContextProviderHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContextProviderHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContextualRestrictionsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListContextualRestrictionsResponse
}

// Status returns HTTPResponse.Status
func (r ListContextualRestrictionsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContextualRestrictionsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContextualRestrictionHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ContextualRestrictionResponse
}

// Status returns HTTPResponse.Status
func (r CreateContextualRestrictionHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContextualRestrictionHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDataDocksRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DataDock
}

// Status returns HTTPResponse.Status
func (r ListDataDocksRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDataDocksRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshOrgDataDocksRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshDataDocksResponse
}

// Status returns HTTPResponse.Status
func (r RefreshOrgDataDocksRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshOrgDataDocksRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEffectiveSecuritySettingsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EffectiveSecuritySettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetEffectiveSecuritySettingsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEffectiveSecuritySettingsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrgSecuritySettingsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSecuritySettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetOrgSecuritySettingsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrgSecuritySettingsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrgSecuritySettingsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgSecuritySettingsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateOrgSecuritySettingsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrgSecuritySettingsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServiceAccountsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListServiceAccountsResponseData
}

// Status returns HTTPResponse.Status
func (r ListServiceAccountsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceAccountsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadServiceAccountHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DownloadServiceAccountResponse
}

// Status returns HTTPResponse.Status
func (r DownloadServiceAccountHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadServiceAccountHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTableClassificationsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTableClassificationsResponse
}

// Status returns HTTPResponse.Status
func (r ListTableClassificationsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTableClassificationsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableClassificationHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TableClassificationResponse
}

// Status returns HTTPResponse.Status
func (r CreateTableClassificationHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableClassificationHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AiClassifyHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AiClassifyResponseBody
}

// Status returns HTTPResponse.Status
func (r AiClassifyHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AiClassifyHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableClassificationStatsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClassificationStatsResponse
}

// Status returns HTTPResponse.Status
func (r GetTableClassificationStatsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableClassificationStatsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTableClassificationHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTableClassificationHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTableClassificationHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTableClassificationHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableClassificationResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTableClassificationHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTableClassificationHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserContextHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserContextResponse
}

// Status returns HTTPResponse.Status
func (r GetUserContextHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserContextHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePipelineRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreatePipelineRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePipelineRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountRefsRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CountRefsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountRefsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRefsRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Ref
}

// Status returns HTTPResponse.Status
func (r ListRefsRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRefsRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRefRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
}

// Status returns HTTPResponse.Status
func (r UpdateRefRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRefRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelQueryHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelQueryHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelQueryHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteQueryHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryResult
}

// Status returns HTTPResponse.Status
func (r ExecuteQueryHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteQueryHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHistoryHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]QueryHistoryEntry
}

// Status returns HTTPResponse.Status
func (r GetHistoryHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHistoryHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSavedQueriesHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SavedQuery
}

// Status returns HTTPResponse.Status
func (r ListSavedQueriesHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSavedQueriesHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSavedQueryHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SavedQuery
}

// Status returns HTTPResponse.Status
func (r CreateSavedQueryHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSavedQueryHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSavedQueryHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSavedQueryHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSavedQueryHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSavedQueryHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SavedQuery
}

// Status returns HTTPResponse.Status
func (r GetSavedQueryHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSavedQueryHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSavedQueryHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SavedQuery
}

// Status returns HTTPResponse.Status
func (r UpdateSavedQueryHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSavedQueryHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResultsHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResultsPage
}

// Status returns HTTPResponse.Status
func (r GetResultsHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResultsHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaHandlerRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrinoMetadata
}

// Status returns HTTPResponse.Status
func (r GetSchemaHandlerRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaHandlerRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnifiedCatalogRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnifiedCatalogResponse
}

// Status returns HTTPResponse.Status
func (r GetUnifiedCatalogRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnifiedCatalogRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserRes struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
}

// Status returns HTTPResponse.Status
func (r CreateUserRes) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserRes) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePipelineV2Res struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PipelineResponseData
}

// Status returns HTTPResponse.Status
func (r CreatePipelineV2Res) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePipelineV2Res) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// HandleGetConsoleConfigWithResponse request returning *HandleGetConsoleConfigRes
func (c *ClientWithResponses) HandleGetConsoleConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HandleGetConsoleConfigRes, error) {
	rsp, err := c.HandleGetConsoleConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHandleGetConsoleConfigRes(rsp)
}

// DeleteContextProviderHandlerWithResponse request returning *DeleteContextProviderHandlerRes
func (c *ClientWithResponses) DeleteContextProviderHandlerWithResponse(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteContextProviderHandlerRes, error) {
	rsp, err := c.DeleteContextProviderHandler(ctx, providerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContextProviderHandlerRes(rsp)
}

// GetContextProviderHandlerWithResponse request returning *GetContextProviderHandlerRes
func (c *ClientWithResponses) GetContextProviderHandlerWithResponse(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetContextProviderHandlerRes, error) {
	rsp, err := c.GetContextProviderHandler(ctx, providerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContextProviderHandlerRes(rsp)
}

// UpdateContextProviderHandlerWithBodyWithResponse request with arbitrary body returning *UpdateContextProviderHandlerRes
func (c *ClientWithResponses) UpdateContextProviderHandlerWithBodyWithResponse(ctx context.Context, providerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContextProviderHandlerRes, error) {
	rsp, err := c.UpdateContextProviderHandlerWithBody(ctx, providerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContextProviderHandlerRes(rsp)
}

func (c *ClientWithResponses) UpdateContextProviderHandlerWithResponse(ctx context.Context, providerId openapi_types.UUID, body UpdateContextProviderHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContextProviderHandlerRes, error) {
	rsp, err := c.UpdateContextProviderHandler(ctx, providerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContextProviderHandlerRes(rsp)
}

// SyncContextProviderHandlerWithResponse request returning *SyncContextProviderHandlerRes
func (c *ClientWithResponses) SyncContextProviderHandlerWithResponse(ctx context.Context, providerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*SyncContextProviderHandlerRes, error) {
	rsp, err := c.SyncContextProviderHandler(ctx, providerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncContextProviderHandlerRes(rsp)
}

// DeleteContextualRestrictionHandlerWithResponse request returning *DeleteContextualRestrictionHandlerRes
func (c *ClientWithResponses) DeleteContextualRestrictionHandlerWithResponse(ctx context.Context, restrictionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteContextualRestrictionHandlerRes, error) {
	rsp, err := c.DeleteContextualRestrictionHandler(ctx, restrictionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContextualRestrictionHandlerRes(rsp)
}

// GetContextualRestrictionHandlerWithResponse request returning *GetContextualRestrictionHandlerRes
func (c *ClientWithResponses) GetContextualRestrictionHandlerWithResponse(ctx context.Context, restrictionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetContextualRestrictionHandlerRes, error) {
	rsp, err := c.GetContextualRestrictionHandler(ctx, restrictionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContextualRestrictionHandlerRes(rsp)
}

// UpdateContextualRestrictionHandlerWithBodyWithResponse request with arbitrary body returning *UpdateContextualRestrictionHandlerRes
func (c *ClientWithResponses) UpdateContextualRestrictionHandlerWithBodyWithResponse(ctx context.Context, restrictionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContextualRestrictionHandlerRes, error) {
	rsp, err := c.UpdateContextualRestrictionHandlerWithBody(ctx, restrictionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContextualRestrictionHandlerRes(rsp)
}

func (c *ClientWithResponses) UpdateContextualRestrictionHandlerWithResponse(ctx context.Context, restrictionId openapi_types.UUID, body UpdateContextualRestrictionHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContextualRestrictionHandlerRes, error) {
	rsp, err := c.UpdateContextualRestrictionHandler(ctx, restrictionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContextualRestrictionHandlerRes(rsp)
}

// CreateBucketDataContainerWithBodyWithResponse request with arbitrary body returning *CreateBucketDataContainerRes
func (c *ClientWithResponses) CreateBucketDataContainerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBucketDataContainerRes, error) {
	rsp, err := c.CreateBucketDataContainerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketDataContainerRes(rsp)
}

func (c *ClientWithResponses) CreateBucketDataContainerWithResponse(ctx context.Context, body CreateBucketDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBucketDataContainerRes, error) {
	rsp, err := c.CreateBucketDataContainer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketDataContainerRes(rsp)
}

// DeleteBucketFileWithResponse request returning *DeleteBucketFileRes
func (c *ClientWithResponses) DeleteBucketFileWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, params *DeleteBucketFileParams, reqEditors ...RequestEditorFn) (*DeleteBucketFileRes, error) {
	rsp, err := c.DeleteBucketFile(ctx, dataContainerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBucketFileRes(rsp)
}

// ListBucketFilesWithResponse request returning *ListBucketFilesRes
func (c *ClientWithResponses) ListBucketFilesWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, params *ListBucketFilesParams, reqEditors ...RequestEditorFn) (*ListBucketFilesRes, error) {
	rsp, err := c.ListBucketFiles(ctx, dataContainerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBucketFilesRes(rsp)
}

// UploadBucketFileWithResponse request returning *UploadBucketFileRes
func (c *ClientWithResponses) UploadBucketFileWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*UploadBucketFileRes, error) {
	rsp, err := c.UploadBucketFile(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadBucketFileRes(rsp)
}

// DownloadBucketFileWithResponse request returning *DownloadBucketFileRes
func (c *ClientWithResponses) DownloadBucketFileWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, params *DownloadBucketFileParams, reqEditors ...RequestEditorFn) (*DownloadBucketFileRes, error) {
	rsp, err := c.DownloadBucketFile(ctx, dataContainerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadBucketFileRes(rsp)
}

// CreateBucketFolderWithBodyWithResponse request with arbitrary body returning *CreateBucketFolderRes
func (c *ClientWithResponses) CreateBucketFolderWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBucketFolderRes, error) {
	rsp, err := c.CreateBucketFolderWithBody(ctx, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketFolderRes(rsp)
}

func (c *ClientWithResponses) CreateBucketFolderWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CreateBucketFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBucketFolderRes, error) {
	rsp, err := c.CreateBucketFolder(ctx, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBucketFolderRes(rsp)
}

// GetBucketStatsWithResponse request returning *GetBucketStatsRes
func (c *ClientWithResponses) GetBucketStatsWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetBucketStatsRes, error) {
	rsp, err := c.GetBucketStats(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBucketStatsRes(rsp)
}

// GetFakerFieldTypesWithResponse request returning *GetFakerFieldTypesRes
func (c *ClientWithResponses) GetFakerFieldTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFakerFieldTypesRes, error) {
	rsp, err := c.GetFakerFieldTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFakerFieldTypesRes(rsp)
}

// GetFakerSchemasWithResponse request returning *GetFakerSchemasRes
func (c *ClientWithResponses) GetFakerSchemasWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFakerSchemasRes, error) {
	rsp, err := c.GetFakerSchemas(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFakerSchemasRes(rsp)
}

// CreateFakerSchemaWithBodyWithResponse request with arbitrary body returning *CreateFakerSchemaRes
func (c *ClientWithResponses) CreateFakerSchemaWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFakerSchemaRes, error) {
	rsp, err := c.CreateFakerSchemaWithBody(ctx, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFakerSchemaRes(rsp)
}

func (c *ClientWithResponses) CreateFakerSchemaWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CreateFakerSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFakerSchemaRes, error) {
	rsp, err := c.CreateFakerSchema(ctx, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFakerSchemaRes(rsp)
}

// DeleteFakerSchemaWithResponse request returning *DeleteFakerSchemaRes
func (c *ClientWithResponses) DeleteFakerSchemaWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFakerSchemaRes, error) {
	rsp, err := c.DeleteFakerSchema(ctx, dataContainerId, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFakerSchemaRes(rsp)
}

// CreateFakerTableWithBodyWithResponse request with arbitrary body returning *CreateFakerTableRes
func (c *ClientWithResponses) CreateFakerTableWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFakerTableRes, error) {
	rsp, err := c.CreateFakerTableWithBody(ctx, dataContainerId, schemaId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFakerTableRes(rsp)
}

func (c *ClientWithResponses) CreateFakerTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFakerTableRes, error) {
	rsp, err := c.CreateFakerTable(ctx, dataContainerId, schemaId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFakerTableRes(rsp)
}

// CreateFakerTableStructuredWithBodyWithResponse request with arbitrary body returning *CreateFakerTableStructuredRes
func (c *ClientWithResponses) CreateFakerTableStructuredWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFakerTableStructuredRes, error) {
	rsp, err := c.CreateFakerTableStructuredWithBody(ctx, dataContainerId, schemaId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFakerTableStructuredRes(rsp)
}

func (c *ClientWithResponses) CreateFakerTableStructuredWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, schemaId openapi_types.UUID, body CreateFakerTableStructuredJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFakerTableStructuredRes, error) {
	rsp, err := c.CreateFakerTableStructured(ctx, dataContainerId, schemaId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFakerTableStructuredRes(rsp)
}

// GetFakerTablesWithResponse request returning *GetFakerTablesRes
func (c *ClientWithResponses) GetFakerTablesWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFakerTablesRes, error) {
	rsp, err := c.GetFakerTables(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFakerTablesRes(rsp)
}

// DeleteFakerTableWithResponse request returning *DeleteFakerTableRes
func (c *ClientWithResponses) DeleteFakerTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFakerTableRes, error) {
	rsp, err := c.DeleteFakerTable(ctx, dataContainerId, tableId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFakerTableRes(rsp)
}

// GetFakerTableWithResponse request returning *GetFakerTableRes
func (c *ClientWithResponses) GetFakerTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFakerTableRes, error) {
	rsp, err := c.GetFakerTable(ctx, dataContainerId, tableId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFakerTableRes(rsp)
}

// UpdateFakerTableWithBodyWithResponse request with arbitrary body returning *UpdateFakerTableRes
func (c *ClientWithResponses) UpdateFakerTableWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFakerTableRes, error) {
	rsp, err := c.UpdateFakerTableWithBody(ctx, dataContainerId, tableId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFakerTableRes(rsp)
}

func (c *ClientWithResponses) UpdateFakerTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, tableId openapi_types.UUID, body UpdateFakerTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFakerTableRes, error) {
	rsp, err := c.UpdateFakerTable(ctx, dataContainerId, tableId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFakerTableRes(rsp)
}

// CreateIcebergDataContainerWithBodyWithResponse request with arbitrary body returning *CreateIcebergDataContainerRes
func (c *ClientWithResponses) CreateIcebergDataContainerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIcebergDataContainerRes, error) {
	rsp, err := c.CreateIcebergDataContainerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIcebergDataContainerRes(rsp)
}

func (c *ClientWithResponses) CreateIcebergDataContainerWithResponse(ctx context.Context, body CreateIcebergDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIcebergDataContainerRes, error) {
	rsp, err := c.CreateIcebergDataContainer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIcebergDataContainerRes(rsp)
}

// GetIcebergDataContainerWithResponse request returning *GetIcebergDataContainerRes
func (c *ClientWithResponses) GetIcebergDataContainerWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetIcebergDataContainerRes, error) {
	rsp, err := c.GetIcebergDataContainer(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIcebergDataContainerRes(rsp)
}

// GetSchemasWithResponse request returning *GetSchemasRes
func (c *ClientWithResponses) GetSchemasWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSchemasRes, error) {
	rsp, err := c.GetSchemas(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemasRes(rsp)
}

// CreateSchemaWithBodyWithResponse request with arbitrary body returning *CreateSchemaRes
func (c *ClientWithResponses) CreateSchemaWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchemaRes, error) {
	rsp, err := c.CreateSchemaWithBody(ctx, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchemaRes(rsp)
}

func (c *ClientWithResponses) CreateSchemaWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchemaRes, error) {
	rsp, err := c.CreateSchema(ctx, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchemaRes(rsp)
}

// GetTablesWithResponse request returning *GetTablesRes
func (c *ClientWithResponses) GetTablesWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetTablesRes, error) {
	rsp, err := c.GetTables(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTablesRes(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableRes
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableRes, error) {
	rsp, err := c.CreateTableWithBody(ctx, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableRes(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableRes, error) {
	rsp, err := c.CreateTable(ctx, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableRes(rsp)
}

// CloneTableWithBodyWithResponse request with arbitrary body returning *CloneTableRes
func (c *ClientWithResponses) CloneTableWithBodyWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneTableRes, error) {
	rsp, err := c.CloneTableWithBody(ctx, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneTableRes(rsp)
}

func (c *ClientWithResponses) CloneTableWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, body CloneTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneTableRes, error) {
	rsp, err := c.CloneTable(ctx, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneTableRes(rsp)
}

// DeleteDataContainerWithResponse request returning *DeleteDataContainerRes
func (c *ClientWithResponses) DeleteDataContainerWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDataContainerRes, error) {
	rsp, err := c.DeleteDataContainer(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataContainerRes(rsp)
}

// GetDataContainerWithResponse request returning *GetDataContainerRes
func (c *ClientWithResponses) GetDataContainerWithResponse(ctx context.Context, dataContainerId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDataContainerRes, error) {
	rsp, err := c.GetDataContainer(ctx, dataContainerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataContainerRes(rsp)
}

// CreateDataDockCrdWithBodyWithResponse request with arbitrary body returning *CreateDataDockCrdRes
func (c *ClientWithResponses) CreateDataDockCrdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataDockCrdRes, error) {
	rsp, err := c.CreateDataDockCrdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataDockCrdRes(rsp)
}

func (c *ClientWithResponses) CreateDataDockCrdWithResponse(ctx context.Context, body CreateDataDockCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataDockCrdRes, error) {
	rsp, err := c.CreateDataDockCrd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataDockCrdRes(rsp)
}

// DeleteDataDockCrdWithResponse request returning *DeleteDataDockCrdRes
func (c *ClientWithResponses) DeleteDataDockCrdWithResponse(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteDataDockCrdRes, error) {
	rsp, err := c.DeleteDataDockCrd(ctx, dataDockId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataDockCrdRes(rsp)
}

// ListDataContainersWithResponse request returning *ListDataContainersRes
func (c *ClientWithResponses) ListDataContainersWithResponse(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListDataContainersRes, error) {
	rsp, err := c.ListDataContainers(ctx, dataDockId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDataContainersRes(rsp)
}

// ArchiveExportDataContainerWithBodyWithResponse request with arbitrary body returning *ArchiveExportDataContainerRes
func (c *ClientWithResponses) ArchiveExportDataContainerWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveExportDataContainerRes, error) {
	rsp, err := c.ArchiveExportDataContainerWithBody(ctx, dataDockId, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveExportDataContainerRes(rsp)
}

func (c *ClientWithResponses) ArchiveExportDataContainerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveExportDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveExportDataContainerRes, error) {
	rsp, err := c.ArchiveExportDataContainer(ctx, dataDockId, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveExportDataContainerRes(rsp)
}

// ArchiveImportDataContainerWithBodyWithResponse request with arbitrary body returning *ArchiveImportDataContainerRes
func (c *ClientWithResponses) ArchiveImportDataContainerWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveImportDataContainerRes, error) {
	rsp, err := c.ArchiveImportDataContainerWithBody(ctx, dataDockId, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveImportDataContainerRes(rsp)
}

func (c *ClientWithResponses) ArchiveImportDataContainerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body ArchiveImportDataContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveImportDataContainerRes, error) {
	rsp, err := c.ArchiveImportDataContainer(ctx, dataDockId, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveImportDataContainerRes(rsp)
}

// AbortMultipartUploadWithBodyWithResponse request with arbitrary body returning *AbortMultipartUploadRes
func (c *ClientWithResponses) AbortMultipartUploadWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortMultipartUploadRes, error) {
	rsp, err := c.AbortMultipartUploadWithBody(ctx, dataDockId, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortMultipartUploadRes(rsp)
}

func (c *ClientWithResponses) AbortMultipartUploadWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body AbortMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortMultipartUploadRes, error) {
	rsp, err := c.AbortMultipartUpload(ctx, dataDockId, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortMultipartUploadRes(rsp)
}

// CompleteMultipartUploadWithBodyWithResponse request with arbitrary body returning *CompleteMultipartUploadRes
func (c *ClientWithResponses) CompleteMultipartUploadWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteMultipartUploadRes, error) {
	rsp, err := c.CompleteMultipartUploadWithBody(ctx, dataDockId, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteMultipartUploadRes(rsp)
}

func (c *ClientWithResponses) CompleteMultipartUploadWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body CompleteMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteMultipartUploadRes, error) {
	rsp, err := c.CompleteMultipartUpload(ctx, dataDockId, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteMultipartUploadRes(rsp)
}

// PrepareArchiveImportWithBodyWithResponse request with arbitrary body returning *PrepareArchiveImportRes
func (c *ClientWithResponses) PrepareArchiveImportWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareArchiveImportRes, error) {
	rsp, err := c.PrepareArchiveImportWithBody(ctx, dataDockId, dataContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareArchiveImportRes(rsp)
}

func (c *ClientWithResponses) PrepareArchiveImportWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, body PrepareArchiveImportJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareArchiveImportRes, error) {
	rsp, err := c.PrepareArchiveImport(ctx, dataDockId, dataContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareArchiveImportRes(rsp)
}

// ListArchiveOperationsWithResponse request returning *ListArchiveOperationsRes
func (c *ClientWithResponses) ListArchiveOperationsWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, params *ListArchiveOperationsParams, reqEditors ...RequestEditorFn) (*ListArchiveOperationsRes, error) {
	rsp, err := c.ListArchiveOperations(ctx, dataDockId, dataContainerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArchiveOperationsRes(rsp)
}

// GetArchiveOperationWithResponse request returning *GetArchiveOperationRes
func (c *ClientWithResponses) GetArchiveOperationWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetArchiveOperationRes, error) {
	rsp, err := c.GetArchiveOperation(ctx, dataDockId, dataContainerId, operationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArchiveOperationRes(rsp)
}

// DownloadArchiveOperationWithResponse request returning *DownloadArchiveOperationRes
func (c *ClientWithResponses) DownloadArchiveOperationWithResponse(ctx context.Context, dataDockId openapi_types.UUID, dataContainerId openapi_types.UUID, operationId openapi_types.UUID, params *DownloadArchiveOperationParams, reqEditors ...RequestEditorFn) (*DownloadArchiveOperationRes, error) {
	rsp, err := c.DownloadArchiveOperation(ctx, dataDockId, dataContainerId, operationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadArchiveOperationRes(rsp)
}

// GetDataDockSecuritySettingsHandlerWithResponse request returning *GetDataDockSecuritySettingsHandlerRes
func (c *ClientWithResponses) GetDataDockSecuritySettingsHandlerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetDataDockSecuritySettingsHandlerRes, error) {
	rsp, err := c.GetDataDockSecuritySettingsHandler(ctx, dataDockId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataDockSecuritySettingsHandlerRes(rsp)
}

// UpdateDataDockSecuritySettingsHandlerWithBodyWithResponse request with arbitrary body returning *UpdateDataDockSecuritySettingsHandlerRes
func (c *ClientWithResponses) UpdateDataDockSecuritySettingsHandlerWithBodyWithResponse(ctx context.Context, dataDockId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataDockSecuritySettingsHandlerRes, error) {
	rsp, err := c.UpdateDataDockSecuritySettingsHandlerWithBody(ctx, dataDockId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataDockSecuritySettingsHandlerRes(rsp)
}

func (c *ClientWithResponses) UpdateDataDockSecuritySettingsHandlerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, body UpdateDataDockSecuritySettingsHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataDockSecuritySettingsHandlerRes, error) {
	rsp, err := c.UpdateDataDockSecuritySettingsHandler(ctx, dataDockId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataDockSecuritySettingsHandlerRes(rsp)
}

// ListHarborDataDockWithResponse request returning *ListHarborDataDockRes
func (c *ClientWithResponses) ListHarborDataDockWithResponse(ctx context.Context, harborId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListHarborDataDockRes, error) {
	rsp, err := c.ListHarborDataDock(ctx, harborId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHarborDataDockRes(rsp)
}

// ListOrganizationsWithResponse request returning *ListOrganizationsRes
func (c *ClientWithResponses) ListOrganizationsWithResponse(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*ListOrganizationsRes, error) {
	rsp, err := c.ListOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganizationsRes(rsp)
}

// CreateOrganizationCrdWithBodyWithResponse request with arbitrary body returning *CreateOrganizationCrdRes
func (c *ClientWithResponses) CreateOrganizationCrdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrganizationCrdRes, error) {
	rsp, err := c.CreateOrganizationCrdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationCrdRes(rsp)
}

func (c *ClientWithResponses) CreateOrganizationCrdWithResponse(ctx context.Context, body CreateOrganizationCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrganizationCrdRes, error) {
	rsp, err := c.CreateOrganizationCrd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrganizationCrdRes(rsp)
}

// CheckOrganizationNameAvailabilityWithResponse request returning *CheckOrganizationNameAvailabilityRes
func (c *ClientWithResponses) CheckOrganizationNameAvailabilityWithResponse(ctx context.Context, params *CheckOrganizationNameAvailabilityParams, reqEditors ...RequestEditorFn) (*CheckOrganizationNameAvailabilityRes, error) {
	rsp, err := c.CheckOrganizationNameAvailability(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckOrganizationNameAvailabilityRes(rsp)
}

// GetOrganizationByIdWithResponse request returning *GetOrganizationByIdRes
func (c *ClientWithResponses) GetOrganizationByIdWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetOrganizationByIdRes, error) {
	rsp, err := c.GetOrganizationById(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationByIdRes(rsp)
}

// ListApiKeysWithResponse request returning *ListApiKeysRes
func (c *ClientWithResponses) ListApiKeysWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListApiKeysRes, error) {
	rsp, err := c.ListApiKeys(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysRes(rsp)
}

// CreateApiKeyWithBodyWithResponse request with arbitrary body returning *CreateApiKeyRes
func (c *ClientWithResponses) CreateApiKeyWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyRes, error) {
	rsp, err := c.CreateApiKeyWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyRes(rsp)
}

func (c *ClientWithResponses) CreateApiKeyWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyRes, error) {
	rsp, err := c.CreateApiKey(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyRes(rsp)
}

// RevokeApiKeyWithResponse request returning *RevokeApiKeyRes
func (c *ClientWithResponses) RevokeApiKeyWithResponse(ctx context.Context, organizationId openapi_types.UUID, keyId openapi_types.UUID, reqEditors ...RequestEditorFn) (*RevokeApiKeyRes, error) {
	rsp, err := c.RevokeApiKey(ctx, organizationId, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeApiKeyRes(rsp)
}

// DeleteOrganizationCrdWithResponse request returning *DeleteOrganizationCrdRes
func (c *ClientWithResponses) DeleteOrganizationCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteOrganizationCrdRes, error) {
	rsp, err := c.DeleteOrganizationCrd(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationCrdRes(rsp)
}

// ListHarborsWithResponse request returning *ListHarborsRes
func (c *ClientWithResponses) ListHarborsWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListHarborsParams, reqEditors ...RequestEditorFn) (*ListHarborsRes, error) {
	rsp, err := c.ListHarbors(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListHarborsRes(rsp)
}

// CreateHarborCrdWithBodyWithResponse request with arbitrary body returning *CreateHarborCrdRes
func (c *ClientWithResponses) CreateHarborCrdWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHarborCrdRes, error) {
	rsp, err := c.CreateHarborCrdWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHarborCrdRes(rsp)
}

func (c *ClientWithResponses) CreateHarborCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateHarborCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHarborCrdRes, error) {
	rsp, err := c.CreateHarborCrd(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHarborCrdRes(rsp)
}

// DeleteHarborCrdWithResponse request returning *DeleteHarborCrdRes
func (c *ClientWithResponses) DeleteHarborCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, harborSlug string, reqEditors ...RequestEditorFn) (*DeleteHarborCrdRes, error) {
	rsp, err := c.DeleteHarborCrd(ctx, organizationId, harborSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHarborCrdRes(rsp)
}

// CheckHarborNameAvailableWithResponse request returning *CheckHarborNameAvailableRes
func (c *ClientWithResponses) CheckHarborNameAvailableWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*CheckHarborNameAvailableRes, error) {
	rsp, err := c.CheckHarborNameAvailable(ctx, organizationId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckHarborNameAvailableRes(rsp)
}

// ListModelServingsWithResponse request returning *ListModelServingsRes
func (c *ClientWithResponses) ListModelServingsWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListModelServingsRes, error) {
	rsp, err := c.ListModelServings(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelServingsRes(rsp)
}

// CreateModelServingWithBodyWithResponse request with arbitrary body returning *CreateModelServingRes
func (c *ClientWithResponses) CreateModelServingWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelServingRes, error) {
	rsp, err := c.CreateModelServingWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelServingRes(rsp)
}

func (c *ClientWithResponses) CreateModelServingWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateModelServingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelServingRes, error) {
	rsp, err := c.CreateModelServing(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelServingRes(rsp)
}

// DeleteModelServingWithResponse request returning *DeleteModelServingRes
func (c *ClientWithResponses) DeleteModelServingWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*DeleteModelServingRes, error) {
	rsp, err := c.DeleteModelServing(ctx, organizationId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModelServingRes(rsp)
}

// GetModelServingWithResponse request returning *GetModelServingRes
func (c *ClientWithResponses) GetModelServingWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, reqEditors ...RequestEditorFn) (*GetModelServingRes, error) {
	rsp, err := c.GetModelServing(ctx, organizationId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModelServingRes(rsp)
}

// PatchModelServingWithBodyWithResponse request with arbitrary body returning *PatchModelServingRes
func (c *ClientWithResponses) PatchModelServingWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchModelServingRes, error) {
	rsp, err := c.PatchModelServingWithBody(ctx, organizationId, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchModelServingRes(rsp)
}

func (c *ClientWithResponses) PatchModelServingWithResponse(ctx context.Context, organizationId openapi_types.UUID, name string, body PatchModelServingJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchModelServingRes, error) {
	rsp, err := c.PatchModelServing(ctx, organizationId, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchModelServingRes(rsp)
}

// ListPipelinesWithResponse request returning *ListPipelinesRes
func (c *ClientWithResponses) ListPipelinesWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListPipelinesRes, error) {
	rsp, err := c.ListPipelines(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPipelinesRes(rsp)
}

// DeletePipelineWithResponse request returning *DeletePipelineRes
func (c *ClientWithResponses) DeletePipelineWithResponse(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeletePipelineRes, error) {
	rsp, err := c.DeletePipeline(ctx, organizationId, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePipelineRes(rsp)
}

// ListPipelineRunsWithResponse request returning *ListPipelineRunsRes
func (c *ClientWithResponses) ListPipelineRunsWithResponse(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListPipelineRunsRes, error) {
	rsp, err := c.ListPipelineRuns(ctx, organizationId, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPipelineRunsRes(rsp)
}

// GetPipelineRunWithResponse request returning *GetPipelineRunRes
func (c *ClientWithResponses) GetPipelineRunWithResponse(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, runId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetPipelineRunRes, error) {
	rsp, err := c.GetPipelineRun(ctx, organizationId, pipelineId, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineRunRes(rsp)
}

// TriggerPipelineWithResponse request returning *TriggerPipelineRes
func (c *ClientWithResponses) TriggerPipelineWithResponse(ctx context.Context, organizationId openapi_types.UUID, pipelineId openapi_types.UUID, reqEditors ...RequestEditorFn) (*TriggerPipelineRes, error) {
	rsp, err := c.TriggerPipeline(ctx, organizationId, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPipelineRes(rsp)
}

// CreateServiceAccountCrdWithBodyWithResponse request with arbitrary body returning *CreateServiceAccountCrdRes
func (c *ClientWithResponses) CreateServiceAccountCrdWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountCrdRes, error) {
	rsp, err := c.CreateServiceAccountCrdWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountCrdRes(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateServiceAccountCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountCrdRes, error) {
	rsp, err := c.CreateServiceAccountCrd(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountCrdRes(rsp)
}

// DeleteServiceAccountCrdWithResponse request returning *DeleteServiceAccountCrdRes
func (c *ClientWithResponses) DeleteServiceAccountCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, clientId string, reqEditors ...RequestEditorFn) (*DeleteServiceAccountCrdRes, error) {
	rsp, err := c.DeleteServiceAccountCrd(ctx, organizationId, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountCrdRes(rsp)
}

// UpdateServiceAccountCrdWithBodyWithResponse request with arbitrary body returning *UpdateServiceAccountCrdRes
func (c *ClientWithResponses) UpdateServiceAccountCrdWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, clientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountCrdRes, error) {
	rsp, err := c.UpdateServiceAccountCrdWithBody(ctx, organizationId, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountCrdRes(rsp)
}

func (c *ClientWithResponses) UpdateServiceAccountCrdWithResponse(ctx context.Context, organizationId openapi_types.UUID, clientId string, body UpdateServiceAccountCrdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountCrdRes, error) {
	rsp, err := c.UpdateServiceAccountCrd(ctx, organizationId, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountCrdRes(rsp)
}

// ListOrgUserAttributesHandlerWithResponse request returning *ListOrgUserAttributesHandlerRes
func (c *ClientWithResponses) ListOrgUserAttributesHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListOrgUserAttributesHandlerRes, error) {
	rsp, err := c.ListOrgUserAttributesHandler(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrgUserAttributesHandlerRes(rsp)
}

// ListOrgUsersWithResponse request returning *ListOrgUsersRes
func (c *ClientWithResponses) ListOrgUsersWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListOrgUsersRes, error) {
	rsp, err := c.ListOrgUsers(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrgUsersRes(rsp)
}

// AddUserToOrganizationWithBodyWithResponse request with arbitrary body returning *AddUserToOrganizationRes
func (c *ClientWithResponses) AddUserToOrganizationWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserToOrganizationRes, error) {
	rsp, err := c.AddUserToOrganizationWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToOrganizationRes(rsp)
}

func (c *ClientWithResponses) AddUserToOrganizationWithResponse(ctx context.Context, organizationId openapi_types.UUID, body AddUserToOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserToOrganizationRes, error) {
	rsp, err := c.AddUserToOrganization(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserToOrganizationRes(rsp)
}

// RemoveUserFromOrganizationWithResponse request returning *RemoveUserFromOrganizationRes
func (c *ClientWithResponses) RemoveUserFromOrganizationWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*RemoveUserFromOrganizationRes, error) {
	rsp, err := c.RemoveUserFromOrganization(ctx, organizationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserFromOrganizationRes(rsp)
}

// ListUserAttributesHandlerWithResponse request returning *ListUserAttributesHandlerRes
func (c *ClientWithResponses) ListUserAttributesHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListUserAttributesHandlerRes, error) {
	rsp, err := c.ListUserAttributesHandler(ctx, organizationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserAttributesHandlerRes(rsp)
}

// AddUserAttributeHandlerWithBodyWithResponse request with arbitrary body returning *AddUserAttributeHandlerRes
func (c *ClientWithResponses) AddUserAttributeHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserAttributeHandlerRes, error) {
	rsp, err := c.AddUserAttributeHandlerWithBody(ctx, organizationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserAttributeHandlerRes(rsp)
}

func (c *ClientWithResponses) AddUserAttributeHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, body AddUserAttributeHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserAttributeHandlerRes, error) {
	rsp, err := c.AddUserAttributeHandler(ctx, organizationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserAttributeHandlerRes(rsp)
}

// SetUserAttributesHandlerWithBodyWithResponse request with arbitrary body returning *SetUserAttributesHandlerRes
func (c *ClientWithResponses) SetUserAttributesHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetUserAttributesHandlerRes, error) {
	rsp, err := c.SetUserAttributesHandlerWithBody(ctx, organizationId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetUserAttributesHandlerRes(rsp)
}

func (c *ClientWithResponses) SetUserAttributesHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, body SetUserAttributesHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetUserAttributesHandlerRes, error) {
	rsp, err := c.SetUserAttributesHandler(ctx, organizationId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetUserAttributesHandlerRes(rsp)
}

// RemoveUserAttributeHandlerWithResponse request returning *RemoveUserAttributeHandlerRes
func (c *ClientWithResponses) RemoveUserAttributeHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId openapi_types.UUID, attribute string, reqEditors ...RequestEditorFn) (*RemoveUserAttributeHandlerRes, error) {
	rsp, err := c.RemoveUserAttributeHandler(ctx, organizationId, userId, attribute, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveUserAttributeHandlerRes(rsp)
}

// ListContextProvidersHandlerWithResponse request returning *ListContextProvidersHandlerRes
func (c *ClientWithResponses) ListContextProvidersHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListContextProvidersHandlerRes, error) {
	rsp, err := c.ListContextProvidersHandler(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContextProvidersHandlerRes(rsp)
}

// CreateContextProviderHandlerWithBodyWithResponse request with arbitrary body returning *CreateContextProviderHandlerRes
func (c *ClientWithResponses) CreateContextProviderHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContextProviderHandlerRes, error) {
	rsp, err := c.CreateContextProviderHandlerWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContextProviderHandlerRes(rsp)
}

func (c *ClientWithResponses) CreateContextProviderHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateContextProviderHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContextProviderHandlerRes, error) {
	rsp, err := c.CreateContextProviderHandler(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContextProviderHandlerRes(rsp)
}

// ListContextualRestrictionsHandlerWithResponse request returning *ListContextualRestrictionsHandlerRes
func (c *ClientWithResponses) ListContextualRestrictionsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListContextualRestrictionsHandlerParams, reqEditors ...RequestEditorFn) (*ListContextualRestrictionsHandlerRes, error) {
	rsp, err := c.ListContextualRestrictionsHandler(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContextualRestrictionsHandlerRes(rsp)
}

// CreateContextualRestrictionHandlerWithBodyWithResponse request with arbitrary body returning *CreateContextualRestrictionHandlerRes
func (c *ClientWithResponses) CreateContextualRestrictionHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContextualRestrictionHandlerRes, error) {
	rsp, err := c.CreateContextualRestrictionHandlerWithBody(ctx, organizationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContextualRestrictionHandlerRes(rsp)
}

func (c *ClientWithResponses) CreateContextualRestrictionHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *CreateContextualRestrictionHandlerParams, body CreateContextualRestrictionHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContextualRestrictionHandlerRes, error) {
	rsp, err := c.CreateContextualRestrictionHandler(ctx, organizationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContextualRestrictionHandlerRes(rsp)
}

// ListDataDocksWithResponse request returning *ListDataDocksRes
func (c *ClientWithResponses) ListDataDocksWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListDataDocksRes, error) {
	rsp, err := c.ListDataDocks(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDataDocksRes(rsp)
}

// RefreshOrgDataDocksWithResponse request returning *RefreshOrgDataDocksRes
func (c *ClientWithResponses) RefreshOrgDataDocksWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*RefreshOrgDataDocksRes, error) {
	rsp, err := c.RefreshOrgDataDocks(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshOrgDataDocksRes(rsp)
}

// GetEffectiveSecuritySettingsHandlerWithResponse request returning *GetEffectiveSecuritySettingsHandlerRes
func (c *ClientWithResponses) GetEffectiveSecuritySettingsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetEffectiveSecuritySettingsHandlerRes, error) {
	rsp, err := c.GetEffectiveSecuritySettingsHandler(ctx, organizationId, dataDockId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEffectiveSecuritySettingsHandlerRes(rsp)
}

// GetOrgSecuritySettingsHandlerWithResponse request returning *GetOrgSecuritySettingsHandlerRes
func (c *ClientWithResponses) GetOrgSecuritySettingsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetOrgSecuritySettingsHandlerRes, error) {
	rsp, err := c.GetOrgSecuritySettingsHandler(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrgSecuritySettingsHandlerRes(rsp)
}

// UpdateOrgSecuritySettingsHandlerWithBodyWithResponse request with arbitrary body returning *UpdateOrgSecuritySettingsHandlerRes
func (c *ClientWithResponses) UpdateOrgSecuritySettingsHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrgSecuritySettingsHandlerRes, error) {
	rsp, err := c.UpdateOrgSecuritySettingsHandlerWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgSecuritySettingsHandlerRes(rsp)
}

func (c *ClientWithResponses) UpdateOrgSecuritySettingsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, body UpdateOrgSecuritySettingsHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrgSecuritySettingsHandlerRes, error) {
	rsp, err := c.UpdateOrgSecuritySettingsHandler(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrgSecuritySettingsHandlerRes(rsp)
}

// ListServiceAccountsHandlerWithResponse request returning *ListServiceAccountsHandlerRes
func (c *ClientWithResponses) ListServiceAccountsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, params *ListServiceAccountsHandlerParams, reqEditors ...RequestEditorFn) (*ListServiceAccountsHandlerRes, error) {
	rsp, err := c.ListServiceAccountsHandler(ctx, organizationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServiceAccountsHandlerRes(rsp)
}

// DownloadServiceAccountHandlerWithResponse request returning *DownloadServiceAccountHandlerRes
func (c *ClientWithResponses) DownloadServiceAccountHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, serviceAccountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DownloadServiceAccountHandlerRes, error) {
	rsp, err := c.DownloadServiceAccountHandler(ctx, organizationId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadServiceAccountHandlerRes(rsp)
}

// ListTableClassificationsHandlerWithResponse request returning *ListTableClassificationsHandlerRes
func (c *ClientWithResponses) ListTableClassificationsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListTableClassificationsHandlerRes, error) {
	rsp, err := c.ListTableClassificationsHandler(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTableClassificationsHandlerRes(rsp)
}

// CreateTableClassificationHandlerWithBodyWithResponse request with arbitrary body returning *CreateTableClassificationHandlerRes
func (c *ClientWithResponses) CreateTableClassificationHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableClassificationHandlerRes, error) {
	rsp, err := c.CreateTableClassificationHandlerWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableClassificationHandlerRes(rsp)
}

func (c *ClientWithResponses) CreateTableClassificationHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, body CreateTableClassificationHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableClassificationHandlerRes, error) {
	rsp, err := c.CreateTableClassificationHandler(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableClassificationHandlerRes(rsp)
}

// AiClassifyHandlerWithBodyWithResponse request with arbitrary body returning *AiClassifyHandlerRes
func (c *ClientWithResponses) AiClassifyHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AiClassifyHandlerRes, error) {
	rsp, err := c.AiClassifyHandlerWithBody(ctx, organizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAiClassifyHandlerRes(rsp)
}

func (c *ClientWithResponses) AiClassifyHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, body AiClassifyHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*AiClassifyHandlerRes, error) {
	rsp, err := c.AiClassifyHandler(ctx, organizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAiClassifyHandlerRes(rsp)
}

// GetTableClassificationStatsHandlerWithResponse request returning *GetTableClassificationStatsHandlerRes
func (c *ClientWithResponses) GetTableClassificationStatsHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetTableClassificationStatsHandlerRes, error) {
	rsp, err := c.GetTableClassificationStatsHandler(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableClassificationStatsHandlerRes(rsp)
}

// DeleteTableClassificationHandlerWithResponse request returning *DeleteTableClassificationHandlerRes
func (c *ClientWithResponses) DeleteTableClassificationHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteTableClassificationHandlerRes, error) {
	rsp, err := c.DeleteTableClassificationHandler(ctx, organizationId, classificationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTableClassificationHandlerRes(rsp)
}

// UpdateTableClassificationHandlerWithBodyWithResponse request with arbitrary body returning *UpdateTableClassificationHandlerRes
func (c *ClientWithResponses) UpdateTableClassificationHandlerWithBodyWithResponse(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableClassificationHandlerRes, error) {
	rsp, err := c.UpdateTableClassificationHandlerWithBody(ctx, organizationId, classificationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableClassificationHandlerRes(rsp)
}

func (c *ClientWithResponses) UpdateTableClassificationHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, classificationId openapi_types.UUID, body UpdateTableClassificationHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableClassificationHandlerRes, error) {
	rsp, err := c.UpdateTableClassificationHandler(ctx, organizationId, classificationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableClassificationHandlerRes(rsp)
}

// GetUserContextHandlerWithResponse request returning *GetUserContextHandlerRes
func (c *ClientWithResponses) GetUserContextHandlerWithResponse(ctx context.Context, organizationId openapi_types.UUID, userId string, reqEditors ...RequestEditorFn) (*GetUserContextHandlerRes, error) {
	rsp, err := c.GetUserContextHandler(ctx, organizationId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserContextHandlerRes(rsp)
}

// CreatePipelineWithBodyWithResponse request with arbitrary body returning *CreatePipelineRes
func (c *ClientWithResponses) CreatePipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineRes, error) {
	rsp, err := c.CreatePipelineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineRes(rsp)
}

func (c *ClientWithResponses) CreatePipelineWithResponse(ctx context.Context, body CreatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineRes, error) {
	rsp, err := c.CreatePipeline(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineRes(rsp)
}

// CountRefsWithBodyWithResponse request with arbitrary body returning *CountRefsRes
func (c *ClientWithResponses) CountRefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CountRefsRes, error) {
	rsp, err := c.CountRefsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountRefsRes(rsp)
}

func (c *ClientWithResponses) CountRefsWithResponse(ctx context.Context, body CountRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*CountRefsRes, error) {
	rsp, err := c.CountRefs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountRefsRes(rsp)
}

// ListRefsWithResponse request returning *ListRefsRes
func (c *ClientWithResponses) ListRefsWithResponse(ctx context.Context, params *ListRefsParams, reqEditors ...RequestEditorFn) (*ListRefsRes, error) {
	rsp, err := c.ListRefs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRefsRes(rsp)
}

// UpdateRefWithBodyWithResponse request with arbitrary body returning *UpdateRefRes
func (c *ClientWithResponses) UpdateRefWithBodyWithResponse(ctx context.Context, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRefRes, error) {
	rsp, err := c.UpdateRefWithBody(ctx, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRefRes(rsp)
}

func (c *ClientWithResponses) UpdateRefWithResponse(ctx context.Context, key string, body UpdateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRefRes, error) {
	rsp, err := c.UpdateRef(ctx, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRefRes(rsp)
}

// CancelQueryHandlerWithResponse request returning *CancelQueryHandlerRes
func (c *ClientWithResponses) CancelQueryHandlerWithResponse(ctx context.Context, trinoQueryId string, params *CancelQueryHandlerParams, reqEditors ...RequestEditorFn) (*CancelQueryHandlerRes, error) {
	rsp, err := c.CancelQueryHandler(ctx, trinoQueryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelQueryHandlerRes(rsp)
}

// ExecuteQueryHandlerWithBodyWithResponse request with arbitrary body returning *ExecuteQueryHandlerRes
func (c *ClientWithResponses) ExecuteQueryHandlerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteQueryHandlerRes, error) {
	rsp, err := c.ExecuteQueryHandlerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteQueryHandlerRes(rsp)
}

func (c *ClientWithResponses) ExecuteQueryHandlerWithResponse(ctx context.Context, body ExecuteQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteQueryHandlerRes, error) {
	rsp, err := c.ExecuteQueryHandler(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteQueryHandlerRes(rsp)
}

// GetHistoryHandlerWithResponse request returning *GetHistoryHandlerRes
func (c *ClientWithResponses) GetHistoryHandlerWithResponse(ctx context.Context, params *GetHistoryHandlerParams, reqEditors ...RequestEditorFn) (*GetHistoryHandlerRes, error) {
	rsp, err := c.GetHistoryHandler(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHistoryHandlerRes(rsp)
}

// ListSavedQueriesHandlerWithResponse request returning *ListSavedQueriesHandlerRes
func (c *ClientWithResponses) ListSavedQueriesHandlerWithResponse(ctx context.Context, params *ListSavedQueriesHandlerParams, reqEditors ...RequestEditorFn) (*ListSavedQueriesHandlerRes, error) {
	rsp, err := c.ListSavedQueriesHandler(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSavedQueriesHandlerRes(rsp)
}

// CreateSavedQueryHandlerWithBodyWithResponse request with arbitrary body returning *CreateSavedQueryHandlerRes
func (c *ClientWithResponses) CreateSavedQueryHandlerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSavedQueryHandlerRes, error) {
	rsp, err := c.CreateSavedQueryHandlerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSavedQueryHandlerRes(rsp)
}

func (c *ClientWithResponses) CreateSavedQueryHandlerWithResponse(ctx context.Context, body CreateSavedQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSavedQueryHandlerRes, error) {
	rsp, err := c.CreateSavedQueryHandler(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSavedQueryHandlerRes(rsp)
}

// DeleteSavedQueryHandlerWithResponse request returning *DeleteSavedQueryHandlerRes
func (c *ClientWithResponses) DeleteSavedQueryHandlerWithResponse(ctx context.Context, queryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteSavedQueryHandlerRes, error) {
	rsp, err := c.DeleteSavedQueryHandler(ctx, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSavedQueryHandlerRes(rsp)
}

// GetSavedQueryHandlerWithResponse request returning *GetSavedQueryHandlerRes
func (c *ClientWithResponses) GetSavedQueryHandlerWithResponse(ctx context.Context, queryId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSavedQueryHandlerRes, error) {
	rsp, err := c.GetSavedQueryHandler(ctx, queryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSavedQueryHandlerRes(rsp)
}

// UpdateSavedQueryHandlerWithBodyWithResponse request with arbitrary body returning *UpdateSavedQueryHandlerRes
func (c *ClientWithResponses) UpdateSavedQueryHandlerWithBodyWithResponse(ctx context.Context, queryId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSavedQueryHandlerRes, error) {
	rsp, err := c.UpdateSavedQueryHandlerWithBody(ctx, queryId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSavedQueryHandlerRes(rsp)
}

func (c *ClientWithResponses) UpdateSavedQueryHandlerWithResponse(ctx context.Context, queryId openapi_types.UUID, body UpdateSavedQueryHandlerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSavedQueryHandlerRes, error) {
	rsp, err := c.UpdateSavedQueryHandler(ctx, queryId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSavedQueryHandlerRes(rsp)
}

// GetResultsHandlerWithResponse request returning *GetResultsHandlerRes
func (c *ClientWithResponses) GetResultsHandlerWithResponse(ctx context.Context, queryId openapi_types.UUID, params *GetResultsHandlerParams, reqEditors ...RequestEditorFn) (*GetResultsHandlerRes, error) {
	rsp, err := c.GetResultsHandler(ctx, queryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResultsHandlerRes(rsp)
}

// GetSchemaHandlerWithResponse request returning *GetSchemaHandlerRes
func (c *ClientWithResponses) GetSchemaHandlerWithResponse(ctx context.Context, dataDockId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSchemaHandlerRes, error) {
	rsp, err := c.GetSchemaHandler(ctx, dataDockId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaHandlerRes(rsp)
}

// GetUnifiedCatalogWithResponse request returning *GetUnifiedCatalogRes
func (c *ClientWithResponses) GetUnifiedCatalogWithResponse(ctx context.Context, params *GetUnifiedCatalogParams, reqEditors ...RequestEditorFn) (*GetUnifiedCatalogRes, error) {
	rsp, err := c.GetUnifiedCatalog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnifiedCatalogRes(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserRes
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserRes, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserRes(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserRes, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserRes(rsp)
}

// CreatePipelineV2WithBodyWithResponse request with arbitrary body returning *CreatePipelineV2Res
func (c *ClientWithResponses) CreatePipelineV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineV2Res, error) {
	rsp, err := c.CreatePipelineV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineV2Res(rsp)
}

func (c *ClientWithResponses) CreatePipelineV2WithResponse(ctx context.Context, body CreatePipelineV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineV2Res, error) {
	rsp, err := c.CreatePipelineV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineV2Res(rsp)
}

// ParseHandleGetConsoleConfigRes parses an HTTP response from a HandleGetConsoleConfigWithResponse call
func ParseHandleGetConsoleConfigRes(rsp *http.Response) (*HandleGetConsoleConfigRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HandleGetConsoleConfigRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConsoleConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteContextProviderHandlerRes parses an HTTP response from a DeleteContextProviderHandlerWithResponse call
func ParseDeleteContextProviderHandlerRes(rsp *http.Response) (*DeleteContextProviderHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContextProviderHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetContextProviderHandlerRes parses an HTTP response from a GetContextProviderHandlerWithResponse call
func ParseGetContextProviderHandlerRes(rsp *http.Response) (*GetContextProviderHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContextProviderHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContextProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateContextProviderHandlerRes parses an HTTP response from a UpdateContextProviderHandlerWithResponse call
func ParseUpdateContextProviderHandlerRes(rsp *http.Response) (*UpdateContextProviderHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateContextProviderHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContextProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSyncContextProviderHandlerRes parses an HTTP response from a SyncContextProviderHandlerWithResponse call
func ParseSyncContextProviderHandlerRes(rsp *http.Response) (*SyncContextProviderHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncContextProviderHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteContextualRestrictionHandlerRes parses an HTTP response from a DeleteContextualRestrictionHandlerWithResponse call
func ParseDeleteContextualRestrictionHandlerRes(rsp *http.Response) (*DeleteContextualRestrictionHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContextualRestrictionHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetContextualRestrictionHandlerRes parses an HTTP response from a GetContextualRestrictionHandlerWithResponse call
func ParseGetContextualRestrictionHandlerRes(rsp *http.Response) (*GetContextualRestrictionHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContextualRestrictionHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContextualRestrictionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateContextualRestrictionHandlerRes parses an HTTP response from a UpdateContextualRestrictionHandlerWithResponse call
func ParseUpdateContextualRestrictionHandlerRes(rsp *http.Response) (*UpdateContextualRestrictionHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateContextualRestrictionHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContextualRestrictionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBucketDataContainerRes parses an HTTP response from a CreateBucketDataContainerWithResponse call
func ParseCreateBucketDataContainerRes(rsp *http.Response) (*CreateBucketDataContainerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBucketDataContainerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DataContainerOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteBucketFileRes parses an HTTP response from a DeleteBucketFileWithResponse call
func ParseDeleteBucketFileRes(rsp *http.Response) (*DeleteBucketFileRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBucketFileRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListBucketFilesRes parses an HTTP response from a ListBucketFilesWithResponse call
func ParseListBucketFilesRes(rsp *http.Response) (*ListBucketFilesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBucketFilesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BucketFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUploadBucketFileRes parses an HTTP response from a UploadBucketFileWithResponse call
func ParseUploadBucketFileRes(rsp *http.Response) (*UploadBucketFileRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadBucketFileRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDownloadBucketFileRes parses an HTTP response from a DownloadBucketFileWithResponse call
func ParseDownloadBucketFileRes(rsp *http.Response) (*DownloadBucketFileRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadBucketFileRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBucketFolderRes parses an HTTP response from a CreateBucketFolderWithResponse call
func ParseCreateBucketFolderRes(rsp *http.Response) (*CreateBucketFolderRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBucketFolderRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBucketStatsRes parses an HTTP response from a GetBucketStatsWithResponse call
func ParseGetBucketStatsRes(rsp *http.Response) (*GetBucketStatsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBucketStatsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFakerFieldTypesRes parses an HTTP response from a GetFakerFieldTypesWithResponse call
func ParseGetFakerFieldTypesRes(rsp *http.Response) (*GetFakerFieldTypesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFakerFieldTypesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFakerFieldTypesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFakerSchemasRes parses an HTTP response from a GetFakerSchemasWithResponse call
func ParseGetFakerSchemasRes(rsp *http.Response) (*GetFakerSchemasRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFakerSchemasRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFakerSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFakerSchemaRes parses an HTTP response from a CreateFakerSchemaWithResponse call
func ParseCreateFakerSchemaRes(rsp *http.Response) (*CreateFakerSchemaRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFakerSchemaRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FakerSchemaOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteFakerSchemaRes parses an HTTP response from a DeleteFakerSchemaWithResponse call
func ParseDeleteFakerSchemaRes(rsp *http.Response) (*DeleteFakerSchemaRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFakerSchemaRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateFakerTableRes parses an HTTP response from a CreateFakerTableWithResponse call
func ParseCreateFakerTableRes(rsp *http.Response) (*CreateFakerTableRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFakerTableRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FakerTableOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCreateFakerTableStructuredRes parses an HTTP response from a CreateFakerTableStructuredWithResponse call
func ParseCreateFakerTableStructuredRes(rsp *http.Response) (*CreateFakerTableStructuredRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFakerTableStructuredRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FakerTableOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetFakerTablesRes parses an HTTP response from a GetFakerTablesWithResponse call
func ParseGetFakerTablesRes(rsp *http.Response) (*GetFakerTablesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFakerTablesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFakerTablesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFakerTableRes parses an HTTP response from a DeleteFakerTableWithResponse call
func ParseDeleteFakerTableRes(rsp *http.Response) (*DeleteFakerTableRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFakerTableRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFakerTableRes parses an HTTP response from a GetFakerTableWithResponse call
func ParseGetFakerTableRes(rsp *http.Response) (*GetFakerTableRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFakerTableRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFakerTableResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFakerTableRes parses an HTTP response from a UpdateFakerTableWithResponse call
func ParseUpdateFakerTableRes(rsp *http.Response) (*UpdateFakerTableRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFakerTableRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FakerTableOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateIcebergDataContainerRes parses an HTTP response from a CreateIcebergDataContainerWithResponse call
func ParseCreateIcebergDataContainerRes(rsp *http.Response) (*CreateIcebergDataContainerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIcebergDataContainerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DataContainerOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetIcebergDataContainerRes parses an HTTP response from a GetIcebergDataContainerWithResponse call
func ParseGetIcebergDataContainerRes(rsp *http.Response) (*GetIcebergDataContainerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIcebergDataContainerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IcebergConnectorDataContainer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemasRes parses an HTTP response from a GetSchemasWithResponse call
func ParseGetSchemasRes(rsp *http.Response) (*GetSchemasRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemasRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IcebergSchemaMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSchemaRes parses an HTTP response from a CreateSchemaWithResponse call
func ParseCreateSchemaRes(rsp *http.Response) (*CreateSchemaRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSchemaRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IcebergSchemaMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetTablesRes parses an HTTP response from a GetTablesWithResponse call
func ParseGetTablesRes(rsp *http.Response) (*GetTablesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTablesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IcebergTableResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTableRes parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableRes(rsp *http.Response) (*CreateTableRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IcebergTableMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCloneTableRes parses an HTTP response from a CloneTableWithResponse call
func ParseCloneTableRes(rsp *http.Response) (*CloneTableRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloneTableRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDataContainerRes parses an HTTP response from a DeleteDataContainerWithResponse call
func ParseDeleteDataContainerRes(rsp *http.Response) (*DeleteDataContainerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataContainerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDataContainerRes parses an HTTP response from a GetDataContainerWithResponse call
func ParseGetDataContainerRes(rsp *http.Response) (*GetDataContainerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataContainerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataContainerOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDataDockCrdRes parses an HTTP response from a CreateDataDockCrdWithResponse call
func ParseCreateDataDockCrdRes(rsp *http.Response) (*CreateDataDockCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDataDockCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DataDockResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteDataDockCrdRes parses an HTTP response from a DeleteDataDockCrdWithResponse call
func ParseDeleteDataDockCrdRes(rsp *http.Response) (*DeleteDataDockCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataDockCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListDataContainersRes parses an HTTP response from a ListDataContainersWithResponse call
func ParseListDataContainersRes(rsp *http.Response) (*ListDataContainersRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDataContainersRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DataContainerOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveExportDataContainerRes parses an HTTP response from a ArchiveExportDataContainerWithResponse call
func ParseArchiveExportDataContainerRes(rsp *http.Response) (*ArchiveExportDataContainerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveExportDataContainerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketArchiveOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveImportDataContainerRes parses an HTTP response from a ArchiveImportDataContainerWithResponse call
func ParseArchiveImportDataContainerRes(rsp *http.Response) (*ArchiveImportDataContainerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveImportDataContainerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketArchiveOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAbortMultipartUploadRes parses an HTTP response from a AbortMultipartUploadWithResponse call
func ParseAbortMultipartUploadRes(rsp *http.Response) (*AbortMultipartUploadRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AbortMultipartUploadRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCompleteMultipartUploadRes parses an HTTP response from a CompleteMultipartUploadWithResponse call
func ParseCompleteMultipartUploadRes(rsp *http.Response) (*CompleteMultipartUploadRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteMultipartUploadRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePrepareArchiveImportRes parses an HTTP response from a PrepareArchiveImportWithResponse call
func ParsePrepareArchiveImportRes(rsp *http.Response) (*PrepareArchiveImportRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareArchiveImportRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrepareArchiveImportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListArchiveOperationsRes parses an HTTP response from a ListArchiveOperationsWithResponse call
func ParseListArchiveOperationsRes(rsp *http.Response) (*ListArchiveOperationsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListArchiveOperationsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BucketArchiveOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetArchiveOperationRes parses an HTTP response from a GetArchiveOperationWithResponse call
func ParseGetArchiveOperationRes(rsp *http.Response) (*GetArchiveOperationRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArchiveOperationRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketArchiveOperation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadArchiveOperationRes parses an HTTP response from a DownloadArchiveOperationWithResponse call
func ParseDownloadArchiveOperationRes(rsp *http.Response) (*DownloadArchiveOperationRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadArchiveOperationRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArchiveDownloadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDataDockSecuritySettingsHandlerRes parses an HTTP response from a GetDataDockSecuritySettingsHandlerWithResponse call
func ParseGetDataDockSecuritySettingsHandlerRes(rsp *http.Response) (*GetDataDockSecuritySettingsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataDockSecuritySettingsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataDockSecuritySettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDataDockSecuritySettingsHandlerRes parses an HTTP response from a UpdateDataDockSecuritySettingsHandlerWithResponse call
func ParseUpdateDataDockSecuritySettingsHandlerRes(rsp *http.Response) (*UpdateDataDockSecuritySettingsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDataDockSecuritySettingsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataDockSecuritySettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListHarborDataDockRes parses an HTTP response from a ListHarborDataDockWithResponse call
func ParseListHarborDataDockRes(rsp *http.Response) (*ListHarborDataDockRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHarborDataDockRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Harbor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOrganizationsRes parses an HTTP response from a ListOrganizationsWithResponse call
func ParseListOrganizationsRes(rsp *http.Response) (*ListOrganizationsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganizationsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Org
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateOrganizationCrdRes parses an HTTP response from a CreateOrganizationCrdWithResponse call
func ParseCreateOrganizationCrdRes(rsp *http.Response) (*CreateOrganizationCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrganizationCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCheckOrganizationNameAvailabilityRes parses an HTTP response from a CheckOrganizationNameAvailabilityWithResponse call
func ParseCheckOrganizationNameAvailabilityRes(rsp *http.Response) (*CheckOrganizationNameAvailabilityRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckOrganizationNameAvailabilityRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckOrganizationNameAvailabilityResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrganizationByIdRes parses an HTTP response from a GetOrganizationByIdWithResponse call
func ParseGetOrganizationByIdRes(rsp *http.Response) (*GetOrganizationByIdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationByIdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Org
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListApiKeysRes parses an HTTP response from a ListApiKeysWithResponse call
func ParseListApiKeysRes(rsp *http.Response) (*ListApiKeysRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApiKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateApiKeyRes parses an HTTP response from a CreateApiKeyWithResponse call
func ParseCreateApiKeyRes(rsp *http.Response) (*CreateApiKeyRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateApiKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRevokeApiKeyRes parses an HTTP response from a RevokeApiKeyWithResponse call
func ParseRevokeApiKeyRes(rsp *http.Response) (*RevokeApiKeyRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeApiKeyRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteOrganizationCrdRes parses an HTTP response from a DeleteOrganizationCrdWithResponse call
func ParseDeleteOrganizationCrdRes(rsp *http.Response) (*DeleteOrganizationCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListHarborsRes parses an HTTP response from a ListHarborsWithResponse call
func ParseListHarborsRes(rsp *http.Response) (*ListHarborsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListHarborsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Harbor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateHarborCrdRes parses an HTTP response from a CreateHarborCrdWithResponse call
func ParseCreateHarborCrdRes(rsp *http.Response) (*CreateHarborCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHarborCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Harbor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteHarborCrdRes parses an HTTP response from a DeleteHarborCrdWithResponse call
func ParseDeleteHarborCrdRes(rsp *http.Response) (*DeleteHarborCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHarborCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCheckHarborNameAvailableRes parses an HTTP response from a CheckHarborNameAvailableWithResponse call
func ParseCheckHarborNameAvailableRes(rsp *http.Response) (*CheckHarborNameAvailableRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckHarborNameAvailableRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckNameAvailabilityResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListModelServingsRes parses an HTTP response from a ListModelServingsWithResponse call
func ParseListModelServingsRes(rsp *http.Response) (*ListModelServingsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelServingsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ModelServingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateModelServingRes parses an HTTP response from a CreateModelServingWithResponse call
func ParseCreateModelServingRes(rsp *http.Response) (*CreateModelServingRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModelServingRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ModelServingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteModelServingRes parses an HTTP response from a DeleteModelServingWithResponse call
func ParseDeleteModelServingRes(rsp *http.Response) (*DeleteModelServingRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModelServingRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetModelServingRes parses an HTTP response from a GetModelServingWithResponse call
func ParseGetModelServingRes(rsp *http.Response) (*GetModelServingRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModelServingRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelServingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchModelServingRes parses an HTTP response from a PatchModelServingWithResponse call
func ParsePatchModelServingRes(rsp *http.Response) (*PatchModelServingRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchModelServingRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelServingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPipelinesRes parses an HTTP response from a ListPipelinesWithResponse call
func ParseListPipelinesRes(rsp *http.Response) (*ListPipelinesRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPipelinesRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PipelineResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePipelineRes parses an HTTP response from a DeletePipelineWithResponse call
func ParseDeletePipelineRes(rsp *http.Response) (*DeletePipelineRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePipelineRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListPipelineRunsRes parses an HTTP response from a ListPipelineRunsWithResponse call
func ParseListPipelineRunsRes(rsp *http.Response) (*ListPipelineRunsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPipelineRunsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRunsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPipelineRunRes parses an HTTP response from a GetPipelineRunWithResponse call
func ParseGetPipelineRunRes(rsp *http.Response) (*GetPipelineRunRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineRunRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRunResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTriggerPipelineRes parses an HTTP response from a TriggerPipelineWithResponse call
func ParseTriggerPipelineRes(rsp *http.Response) (*TriggerPipelineRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerPipelineRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateServiceAccountCrdRes parses an HTTP response from a CreateServiceAccountCrdWithResponse call
func ParseCreateServiceAccountCrdRes(rsp *http.Response) (*CreateServiceAccountCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountCrdRes parses an HTTP response from a DeleteServiceAccountCrdWithResponse call
func ParseDeleteServiceAccountCrdRes(rsp *http.Response) (*DeleteServiceAccountCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateServiceAccountCrdRes parses an HTTP response from a UpdateServiceAccountCrdWithResponse call
func ParseUpdateServiceAccountCrdRes(rsp *http.Response) (*UpdateServiceAccountCrdRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceAccountCrdRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOrgUserAttributesHandlerRes parses an HTTP response from a ListOrgUserAttributesHandlerWithResponse call
func ParseListOrgUserAttributesHandlerRes(rsp *http.Response) (*ListOrgUserAttributesHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrgUserAttributesHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgUserAttributesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListOrgUsersRes parses an HTTP response from a ListOrgUsersWithResponse call
func ParseListOrgUsersRes(rsp *http.Response) (*ListOrgUsersRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrgUsersRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserWithRoles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUserToOrganizationRes parses an HTTP response from a AddUserToOrganizationWithResponse call
func ParseAddUserToOrganizationRes(rsp *http.Response) (*AddUserToOrganizationRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserToOrganizationRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseRemoveUserFromOrganizationRes parses an HTTP response from a RemoveUserFromOrganizationWithResponse call
func ParseRemoveUserFromOrganizationRes(rsp *http.Response) (*RemoveUserFromOrganizationRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserFromOrganizationRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListUserAttributesHandlerRes parses an HTTP response from a ListUserAttributesHandlerWithResponse call
func ParseListUserAttributesHandlerRes(rsp *http.Response) (*ListUserAttributesHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserAttributesHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListUserAttributesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddUserAttributeHandlerRes parses an HTTP response from a AddUserAttributeHandlerWithResponse call
func ParseAddUserAttributeHandlerRes(rsp *http.Response) (*AddUserAttributeHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserAttributeHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetUserAttributesHandlerRes parses an HTTP response from a SetUserAttributesHandlerWithResponse call
func ParseSetUserAttributesHandlerRes(rsp *http.Response) (*SetUserAttributesHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetUserAttributesHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveUserAttributeHandlerRes parses an HTTP response from a RemoveUserAttributeHandlerWithResponse call
func ParseRemoveUserAttributeHandlerRes(rsp *http.Response) (*RemoveUserAttributeHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveUserAttributeHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListContextProvidersHandlerRes parses an HTTP response from a ListContextProvidersHandlerWithResponse call
func ParseListContextProvidersHandlerRes(rsp *http.Response) (*ListContextProvidersHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContextProvidersHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListContextProvidersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateContextProviderHandlerRes parses an HTTP response from a CreateContextProviderHandlerWithResponse call
func ParseCreateContextProviderHandlerRes(rsp *http.Response) (*CreateContextProviderHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContextProviderHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ContextProviderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListContextualRestrictionsHandlerRes parses an HTTP response from a ListContextualRestrictionsHandlerWithResponse call
func ParseListContextualRestrictionsHandlerRes(rsp *http.Response) (*ListContextualRestrictionsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContextualRestrictionsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListContextualRestrictionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateContextualRestrictionHandlerRes parses an HTTP response from a CreateContextualRestrictionHandlerWithResponse call
func ParseCreateContextualRestrictionHandlerRes(rsp *http.Response) (*CreateContextualRestrictionHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContextualRestrictionHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ContextualRestrictionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseListDataDocksRes parses an HTTP response from a ListDataDocksWithResponse call
func ParseListDataDocksRes(rsp *http.Response) (*ListDataDocksRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDataDocksRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DataDock
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRefreshOrgDataDocksRes parses an HTTP response from a RefreshOrgDataDocksWithResponse call
func ParseRefreshOrgDataDocksRes(rsp *http.Response) (*RefreshOrgDataDocksRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshOrgDataDocksRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshDataDocksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEffectiveSecuritySettingsHandlerRes parses an HTTP response from a GetEffectiveSecuritySettingsHandlerWithResponse call
func ParseGetEffectiveSecuritySettingsHandlerRes(rsp *http.Response) (*GetEffectiveSecuritySettingsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEffectiveSecuritySettingsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EffectiveSecuritySettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOrgSecuritySettingsHandlerRes parses an HTTP response from a GetOrgSecuritySettingsHandlerWithResponse call
func ParseGetOrgSecuritySettingsHandlerRes(rsp *http.Response) (*GetOrgSecuritySettingsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrgSecuritySettingsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSecuritySettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateOrgSecuritySettingsHandlerRes parses an HTTP response from a UpdateOrgSecuritySettingsHandlerWithResponse call
func ParseUpdateOrgSecuritySettingsHandlerRes(rsp *http.Response) (*UpdateOrgSecuritySettingsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrgSecuritySettingsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgSecuritySettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListServiceAccountsHandlerRes parses an HTTP response from a ListServiceAccountsHandlerWithResponse call
func ParseListServiceAccountsHandlerRes(rsp *http.Response) (*ListServiceAccountsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServiceAccountsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListServiceAccountsResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadServiceAccountHandlerRes parses an HTTP response from a DownloadServiceAccountHandlerWithResponse call
func ParseDownloadServiceAccountHandlerRes(rsp *http.Response) (*DownloadServiceAccountHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadServiceAccountHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DownloadServiceAccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTableClassificationsHandlerRes parses an HTTP response from a ListTableClassificationsHandlerWithResponse call
func ParseListTableClassificationsHandlerRes(rsp *http.Response) (*ListTableClassificationsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTableClassificationsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTableClassificationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTableClassificationHandlerRes parses an HTTP response from a CreateTableClassificationHandlerWithResponse call
func ParseCreateTableClassificationHandlerRes(rsp *http.Response) (*CreateTableClassificationHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableClassificationHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TableClassificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseAiClassifyHandlerRes parses an HTTP response from a AiClassifyHandlerWithResponse call
func ParseAiClassifyHandlerRes(rsp *http.Response) (*AiClassifyHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AiClassifyHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AiClassifyResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTableClassificationStatsHandlerRes parses an HTTP response from a GetTableClassificationStatsHandlerWithResponse call
func ParseGetTableClassificationStatsHandlerRes(rsp *http.Response) (*GetTableClassificationStatsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableClassificationStatsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClassificationStatsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTableClassificationHandlerRes parses an HTTP response from a DeleteTableClassificationHandlerWithResponse call
func ParseDeleteTableClassificationHandlerRes(rsp *http.Response) (*DeleteTableClassificationHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTableClassificationHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateTableClassificationHandlerRes parses an HTTP response from a UpdateTableClassificationHandlerWithResponse call
func ParseUpdateTableClassificationHandlerRes(rsp *http.Response) (*UpdateTableClassificationHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTableClassificationHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableClassificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserContextHandlerRes parses an HTTP response from a GetUserContextHandlerWithResponse call
func ParseGetUserContextHandlerRes(rsp *http.Response) (*GetUserContextHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserContextHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserContextResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePipelineRes parses an HTTP response from a CreatePipelineWithResponse call
func ParseCreatePipelineRes(rsp *http.Response) (*CreatePipelineRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePipelineRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCountRefsRes parses an HTTP response from a CountRefsWithResponse call
func ParseCountRefsRes(rsp *http.Response) (*CountRefsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountRefsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListRefsRes parses an HTTP response from a ListRefsWithResponse call
func ParseListRefsRes(rsp *http.Response) (*ListRefsRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRefsRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRefRes parses an HTTP response from a UpdateRefWithResponse call
func ParseUpdateRefRes(rsp *http.Response) (*UpdateRefRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRefRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelQueryHandlerRes parses an HTTP response from a CancelQueryHandlerWithResponse call
func ParseCancelQueryHandlerRes(rsp *http.Response) (*CancelQueryHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelQueryHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExecuteQueryHandlerRes parses an HTTP response from a ExecuteQueryHandlerWithResponse call
func ParseExecuteQueryHandlerRes(rsp *http.Response) (*ExecuteQueryHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteQueryHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHistoryHandlerRes parses an HTTP response from a GetHistoryHandlerWithResponse call
func ParseGetHistoryHandlerRes(rsp *http.Response) (*GetHistoryHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHistoryHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []QueryHistoryEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSavedQueriesHandlerRes parses an HTTP response from a ListSavedQueriesHandlerWithResponse call
func ParseListSavedQueriesHandlerRes(rsp *http.Response) (*ListSavedQueriesHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSavedQueriesHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SavedQuery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSavedQueryHandlerRes parses an HTTP response from a CreateSavedQueryHandlerWithResponse call
func ParseCreateSavedQueryHandlerRes(rsp *http.Response) (*CreateSavedQueryHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSavedQueryHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SavedQuery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteSavedQueryHandlerRes parses an HTTP response from a DeleteSavedQueryHandlerWithResponse call
func ParseDeleteSavedQueryHandlerRes(rsp *http.Response) (*DeleteSavedQueryHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSavedQueryHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSavedQueryHandlerRes parses an HTTP response from a GetSavedQueryHandlerWithResponse call
func ParseGetSavedQueryHandlerRes(rsp *http.Response) (*GetSavedQueryHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSavedQueryHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SavedQuery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSavedQueryHandlerRes parses an HTTP response from a UpdateSavedQueryHandlerWithResponse call
func ParseUpdateSavedQueryHandlerRes(rsp *http.Response) (*UpdateSavedQueryHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSavedQueryHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SavedQuery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResultsHandlerRes parses an HTTP response from a GetResultsHandlerWithResponse call
func ParseGetResultsHandlerRes(rsp *http.Response) (*GetResultsHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResultsHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemaHandlerRes parses an HTTP response from a GetSchemaHandlerWithResponse call
func ParseGetSchemaHandlerRes(rsp *http.Response) (*GetSchemaHandlerRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaHandlerRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrinoMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUnifiedCatalogRes parses an HTTP response from a GetUnifiedCatalogWithResponse call
func ParseGetUnifiedCatalogRes(rsp *http.Response) (*GetUnifiedCatalogRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnifiedCatalogRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnifiedCatalogResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUserRes parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserRes(rsp *http.Response) (*CreateUserRes, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserRes{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCreatePipelineV2Res parses an HTTP response from a CreatePipelineV2WithResponse call
func ParseCreatePipelineV2Res(rsp *http.Response) (*CreatePipelineV2Res, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePipelineV2Res{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PipelineResponseData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}
